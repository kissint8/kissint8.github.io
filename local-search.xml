<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git 学习整理</title>
    <link href="/posts/7e40b4c1/"/>
    <url>/posts/7e40b4c1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>笔者时隔一年再次整理关于git较新内容的整理，为日常使用服务，原理不做过多介绍。<br>笔者生产环境是Linux，只做命令行环境的整理。<br>参考：*<a href="https://git-scm.com/book/zh/v2">Git Book version 2</a>*</p></blockquote><h2 id="1-起步"><a href="#1-起步" class="headerlink" title="1. 起步"></a>1. 起步</h2><h3 id="1-1-配置-config"><a href="#1-1-配置-config" class="headerlink" title="1.1 配置(config)"></a>1.1 配置(config)</h3><h4 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h4><p>目前共有三级配置文件，影响范围由低到高：</p><ul><li><code>/etc/gitconfig</code>文件：全局配置文件，通过<code>git config --system</code>写入(需要<strong>root</strong>权限)。</li><li><code>~/.gitconfig</code>文件：用户配置文件，通过<code>git config --global </code>写入。</li><li><code>.git/config</code>文件：本仓库配置文件，通过<code>git config --local</code>写入，<code>--local</code>选项可省略。<br>配置文件应用的优先级中<code>--local</code>最高，<code>--system</code>最低。</li></ul><h4 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#列出当前仓库所使用的全部配置信息</span><span class="token function">git</span> config <span class="token parameter variable">--list</span>   <span class="token comment">#列出各配置项所在的配置文件 </span> <span class="token function">git</span> config <span class="token parameter variable">--list</span> --show-origin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="起步配置项"><a href="#起步配置项" class="headerlink" title="起步配置项"></a>起步配置项</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#（必须）首先配置机器上的用户信息和邮箱地址</span><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"xxx"</span><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"xxx@xx.com"</span><span class="token comment">#（推荐）配置git交互时 默认打开的编辑器</span><span class="token function">git</span> config <span class="token parameter variable">--global</span> core.editor <span class="token function">vim</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="1-2-帮助-help"><a href="#1-2-帮助-help" class="headerlink" title="1.2 帮助(help)"></a>1.2 帮助(help)</h3><p> git 有快速参考和综合手册两类帮助命令。</p><ul><li>通过<code>-h</code>查看快速参考。</li><li>通过<code>-help</code> 、<code>man</code> 、<code>git help</code>都可查看综合手册。</li></ul><h2 id="2-基础操作"><a href="#2-基础操作" class="headerlink" title="2. 基础操作"></a>2. 基础操作</h2><p>创建仓库并对文件进行跟踪，而后对文件的修改进行提交，从而完成版本控制，一般地，下述三条命令解决大部分需求：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> init<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span> <span class="token function">git</span> commit -m<span class="token string">"initial project version"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="2-1-跟踪与暂存-add"><a href="#2-1-跟踪与暂存-add" class="headerlink" title="2.1 跟踪与暂存(add)"></a>2.1 跟踪与暂存(add)</h3><p>使用<code>git add</code>可以对<strong>新文件进行跟踪</strong>，对已跟踪的文件的<strong>修改进行暂存</strong>。经过该命令后，文件或修改将由<strong>工作区</strong>转移到**暂存区(staged)**。</p><h3 id="2-2-删除文件-rm"><a href="#2-2-删除文件-rm" class="headerlink" title="2.2 删除文件(rm)"></a>2.2 删除文件(rm)</h3><ul><li>对未跟踪的文件：直接删除即可。</li><li>对已跟踪的文件：<ul><li>直接删除文件会形成一条删除记录，且未被加到暂存区。(不推荐)</li><li>使用<code>git rm --cached</code> 在暂存区添加一条删除记录，并将文件重置为未跟踪(哪怕文件在之前多次的提交中也没关系)。(取消跟踪)</li><li>使用<code>git rm -f </code> 在暂存区添加一条删除记录，并将文件从磁盘上删除。(推荐删除方式)</li></ul></li></ul><h3 id="2-3文件状态-satus"><a href="#2-3文件状态-satus" class="headerlink" title="2.3文件状态(satus)"></a>2.3文件状态(satus)</h3><p><code>git status</code> 可以输出当前<strong>工作区</strong>和<strong>暂存区</strong>中待处理的<strong>文件状态信息</strong>，并猜测用户可能需要的操作，给出相应的<strong>命令提醒</strong>。<br>一种简化显示是 <code>git status -s</code>，其效果如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-shell-session" data-language="shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">git</span> status <span class="token parameter variable">-s</span> </span></span><span class="token output"> M READMEMM RakefileA  lib/git.rbM  lib/simplegit.rb?? LICENSE.txt</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>左侧一共有两栏，左栏指示暂存区，右栏指示工作区，各标记含义如下：</p><ul><li><code>M</code> : 修改。位于左栏表示修改并加入暂存区，位于右栏表示修改尚未加入暂存区，左右同时有M表示修改加入暂存区后又进行了修改。</li><li><code>A</code>：添加到暂存区的新建文件。</li><li><code>??</code>：新建文件，还未被跟踪。</li><li><code>D</code>：删除。(同M)</li></ul><h3 id="2-4-文件差异-diff"><a href="#2-4-文件差异-diff" class="headerlink" title="2.4 文件差异(diff)"></a>2.4 文件差异(diff)</h3><ul><li><code>git diff</code>查看尚未暂存的修改。</li><li><code>git diff --staged 或 --cached</code>查看提交到暂存区的修改。</li><li><code>git diff commit-id -- file</code> 查看某次提交中某文件的修改(省略<code>-- file</code>则查看的是提交的修改)。<br><em>Note</em>: <code>git diff</code>无法查看未跟踪文件的差异。(合理)<blockquote><p>但是你也可以使用图形化的工具或外部 diff 工具来比较差异。 可以使用 git difftool 命令来调用 emerge 或 vimdiff 等软件（包括商业软件）输出 diff 的分析结果。 使用 git difftool –tool-help 命令来看你的系统支持哪些 Git Diff 插件。???</p></blockquote></li></ul><h3 id="2-5-提交记录-commit"><a href="#2-5-提交记录-commit" class="headerlink" title="2.5 提交记录(commit)"></a>2.5 提交记录(commit)</h3><h4 id="暂存区提交"><a href="#暂存区提交" class="headerlink" title="暂存区提交"></a>暂存区提交</h4><p><code>git commit</code>会将暂存区的内容形成记录，保存到仓库中，并关联一个commit id(本次提交的完整 SHA-1校验和)。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 交互模式 打开默认编辑器 不写提交信息默认为取消提交</span><span class="token function">git</span> commit <span class="token comment"># 在上述基础上将git diff输出在默认编辑器显示出来</span><span class="token function">git</span> commit <span class="token parameter variable">-v</span><span class="token comment">#(使用最广泛)oneline 模式</span><span class="token function">git</span> commit -m<span class="token string">'提交信息'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="暂存并提交"><a href="#暂存并提交" class="headerlink" title="暂存并提交"></a>暂存并提交</h4><p><code>git commit -a </code>命令会将<strong>已跟踪文件的修改</strong>自动添加到暂存区并提交。</p><h3 id="2-6-查看提交历史-log"><a href="#2-6-查看提交历史-log" class="headerlink" title="2.6 查看提交历史(log)"></a>2.6 查看提交历史(log)</h3><p>使用命令<code>git log</code>，查看本地仓库的提交记录。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#使得每次记录只显示单行的摘要，当记录较多时建议采用。</span><span class="token function">git</span> log <span class="token parameter variable">--oneline</span><span class="token comment">#显示每次提交的简略统计信息</span><span class="token function">git</span> log <span class="token parameter variable">--stat</span><span class="token comment">#添加了一些 ASCII 字符串来形象地展示你的分支、合并历史</span><span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token comment">#隐藏历史中杂乱的仓库合并记录</span><span class="token function">git</span> log <span class="token parameter variable">--merge</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>上述命令通常可以结合使用。<br>更多功能: </p><ul><li><code>git log --pretty=format:&quot;%占为符... &quot;</code>可以个性化展示内容，可以在此查看<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#pretty_format">常用占位符</a>。</li><li>提交历史命令还支持很多<a href="https://git-scm.com/book/zh/v2/ch00/limit_options">过滤器选项</a>。</li></ul><h3 id="2-7-撤销-restore-reset"><a href="#2-7-撤销-restore-reset" class="headerlink" title="2.7 撤销(restore reset)"></a>2.7 撤销(restore reset)</h3><h4 id="修补提交"><a href="#修补提交" class="headerlink" title="修补提交"></a>修补提交</h4><p>  当 提交信息写错或者提交后才发现有漏掉的文件，可以通过<code>git commit --amend</code>来进行修补。该命令会将当前暂存区的全部内容添加到最近的一次提交，并允许你重新提填写交信息。</p><h4 id="撤销暂存区"><a href="#撤销暂存区" class="headerlink" title="撤销暂存区"></a>撤销暂存区</h4><p>  当需要把文件从暂存区撤换下来时，可以通过<code>git restore --staged &lt;file&gt;</code>来将文件从暂存区放回工作区。在老版本中的命令是<code>git reset HEAD  &lt;file&gt;</code>。</p><h4 id="撤销工作区修改"><a href="#撤销工作区修改" class="headerlink" title="撤销工作区修改"></a>撤销工作区修改</h4><p>  当需要把工作区内对某个文件的修改撤销时，可以通过<code>git restore &lt;file&gt;</code>来实现，其效果等同于<code>git checkout &lt;file&gt;</code>。</p><h4 id="撤销提交"><a href="#撤销提交" class="headerlink" title="撤销提交"></a>撤销提交</h4><p>  当需要把commit 给撤销回工作区时，可以通过<code>git reset --soft &lt;commit-id&gt;</code>重置HEAD指针，此前提交的修改将全部回到工作区，但你尚未提交的内容(暂存区和工作区)都不受影响。</p><h4 id="撤销删除"><a href="#撤销删除" class="headerlink" title="撤销删除"></a>撤销删除</h4><p>首先要明白，文件之所以能恢复是因为在git版本库中保留了记录，如果你的文件没有提交过(被记录在版本库)，则无法恢复。<br>分为两种情况：</p><ul><li>已删除，但未提交，删除记录在工作区或暂存区：<ul><li>将文件的删除记录恢复到工作区。</li><li>通过<code>git restore &lt;file&gt;</code>即可恢复。</li></ul></li><li>已删除，并提交了删除记录(文件在版本库中被删除)：<ul><li>找到删除文件记录对应的提交 或 更久之前的提交<code>&lt;commit-id&gt;</code>，通过<code>git reset --soft &lt;commit-id&gt;</code>来撤销此前的提交。</li><li>将文件的删除记录恢复到工作区。</li><li>通过<code>git restore &lt;file&gt;</code>即可恢复。</li></ul></li></ul><h3 id="2-8-忽略文件-ignore"><a href="#2-8-忽略文件-ignore" class="headerlink" title="2.8 忽略文件(ignore)"></a>2.8 忽略文件(ignore)</h3><p>对于无需纳入Git管理，且不希望总出现在未跟踪文件列表的文件，可以在<code>.gitignore</code>中配置忽略文件的模式。</p><blockquote><p>要养成<strong>一开始</strong>就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p></blockquote><h4 id="匹配规范"><a href="#匹配规范" class="headerlink" title="匹配规范"></a>匹配规范</h4><ul><li>所有空行 或 以#开头的行 不会匹配。</li><li>以 <code>/</code>开头只在当前目录下匹配，不递归。</li><li>以<code>/</code>结尾只匹配目录而不匹配文件。</li><li>使用<code>!</code>开头来对匹配取反。</li><li>标准<em>glob</em>模式(shell所使用的简化正则表达式)，会<strong>递归</strong>地应用在整个工作区。<ul><li><code>*</code>匹配零个或多个字符。</li><li><code>**</code>匹配任意的中间目录。(与*不同，a&#x2F;**&#x2F;z可以匹配a&#x2F;z)</li><li><code>?</code> 匹配一个字符。</li><li><code>[abc]</code>匹配任何一个在方括号中的字符(a或b或c)。</li><li><code>[a-z]</code>或<code>[0-9]</code> 在方括号中使用<code>-</code>表示匹配范围。</li></ul></li></ul><h4 id="匹配示例"><a href="#匹配示例" class="headerlink" title="匹配示例"></a>匹配示例</h4><figure><div class="code-wrapper"><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#忽略.o .a 文件</span>*.[ao]<span class="token comment"># 对lib.a不忽略(即使前边忽略*.a)</span>! lib.a <span class="token comment">#只忽略当前目录下的Readme文件(不会递归)</span>/Readme <span class="token comment">#忽略任何目录下名为build的目录</span>build/ <span class="token comment"># 忽略doc下的.class 不会递归!注意</span> doc/*.class<span class="token comment"># 忽略doc及其子目录下的.class文件</span> doc/**/ *.class <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="匹配模板"><a href="#匹配模板" class="headerlink" title="匹配模板"></a>匹配模板</h4><p>Github提供了详细的匹配模板，可以在<a href="https://github.com/github/gitignore">gitignore模板仓库</a>查看。</p><h4 id="多级忽略文件"><a href="#多级忽略文件" class="headerlink" title="多级忽略文件"></a>多级忽略文件</h4><p>仓库根目录(与<code>.git</code>同级)下的<code>.gitignore</code>文件会被递归地应用到整个仓库的每个角落，但也可以在子目录下创建额外的<code>.gitignore</code>，该文件将只应用在所在目录中。</p><h4 id="忽略文件不生效"><a href="#忽略文件不生效" class="headerlink" title="忽略文件不生效"></a>忽略文件不生效</h4><p><code>.gitignore</code>只能忽略没有被跟踪的文件(且创建后无需提交即可对未跟踪文件生效)，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。<br>此类问题一般出现于未能及时创建忽略文件的情况下，解决方案是删除本地缓存后，再同提交忽略文件一起提交。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> <span class="token parameter variable">-r</span> <span class="token parameter variable">--cached</span>  文件<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>  <span class="token function">git</span> commit -m<span class="token string">"update .gitignore"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="2-9标签-tag"><a href="#2-9标签-tag" class="headerlink" title="2.9标签(tag)"></a>2.9标签(tag)</h3><h4 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#列出当前仓库的标签清单</span><span class="token function">git</span> tag <span class="token comment">#按照通配符要求列出标签清单</span><span class="token function">git</span> tag <span class="token parameter variable">-l</span> <span class="token string">"v8.9.*"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>git中的标签分为两类：轻量标签和附注标签。</p><ul><li>轻量标签：仅仅相当于某一特定提交的引用，不包括除标签号外的其他信息。</li><li>附注标签：存储在Git版本库中的一个完整对象，是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。<figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#为某次提交创建附注标签</span>it tag <span class="token parameter variable">-a</span> v1.0 <span class="token operator">&lt;</span>commit-id<span class="token operator">></span><span class="token comment">#为某次提交创建轻量级标签</span><span class="token function">git</span> tag <span class="token parameter variable">-lw</span> v1.0 <span class="token operator">&lt;</span>commit-id<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li></ul><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><p>删除标签的操作很简单，只要<code>git tag -d v1.0</code>即可。</p><h2 id="3-分支-branch"><a href="#3-分支-branch" class="headerlink" title="3.分支 (branch)"></a>3.分支 (branch)</h2><h3 id="3-1-分支的基础操作-branch-checkout"><a href="#3-1-分支的基础操作-branch-checkout" class="headerlink" title="3.1 分支的基础操作(branch checkout)"></a>3.1 分支的基础操作(branch checkout)</h3><h4 id="分支查看"><a href="#分支查看" class="headerlink" title="分支查看"></a>分支查看</h4><p>通过<code>git branch</code>可列出本地仓库当前的全部分支，如果需要列出远程分支和分支的指针情况，可以通过<code>git branch -avv</code>来实现。</p><h4 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h4><p>常用的分支创建方式有两种：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 以当前HEAD为父节点 创建新分支</span><span class="token function">git</span> branch <span class="token operator">&lt;</span>分支名<span class="token operator">></span><span class="token comment"># 创建分支 并切换到新分支</span><span class="token function">git</span> checkout <span class="token parameter variable">-b</span> <span class="token operator">&lt;</span>分支名<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h4><p>通过<code>git checkout &lt;分支名&gt;</code>进行分支切换。<br>*Note:*在进行分支切换前，请确保工作区是干净的。可以在完成提交或者贮藏后再切换。</p><h4 id="分支删除"><a href="#分支删除" class="headerlink" title="分支删除"></a>分支删除</h4><p>首先确保不在被删除的分支中，然后通过<code>git branch -d &lt;分支名&gt;</code>来完成对分支的删除。</p><h4 id="分支改名"><a href="#分支改名" class="headerlink" title="分支改名"></a>分支改名</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#若在改名的分支中</span><span class="token function">git</span> branch <span class="token parameter variable">-m</span> <span class="token operator">&lt;</span>新分支名<span class="token operator">></span><span class="token comment">#若不在改名的分支中</span><span class="token function">git</span> branch <span class="token parameter variable">-m</span> <span class="token operator">&lt;</span>旧分支名<span class="token operator">></span> <span class="token operator">&lt;</span>新分支名<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="3-2-分支合并-merge"><a href="#3-2-分支合并-merge" class="headerlink" title="3.2 分支合并(merge)"></a>3.2 分支合并(merge)</h3><h4 id="简单合并"><a href="#简单合并" class="headerlink" title="简单合并"></a>简单合并</h4><p>在分支情形不复杂的情况下，若需要将临时分支B的更改合并到分支A中，只需要：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#切换到A分支 </span><span class="token function">git</span> checkout A <span class="token comment">#将B分支合并到A分支中</span><span class="token function">git</span> merge B <span class="token comment">#(可选)删除临时分支</span><span class="token function">git</span> branch <span class="token parameter variable">-d</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="合并类型"><a href="#合并类型" class="headerlink" title="合并类型"></a>合并类型</h4><p>仍然是B作为A的分支，要将B合并到A中，我们列出分支合并最常见的两种形式：</p><ul><li><code>快进合并(fast-forward)</code>：A分支指针仍然停留在B分支的分叉点上(C2)，A和B仍然是线性的，只要快进移动A的指针到B的位置(C3)即可。<br><img src="https://git-scm.com/book/en/v2/images/basic-branching-4.png" alt="快进合并"></li><li><code>三方合并</code>：A分支指针已领先于B分支的分叉点，A和B不满足线性，需要将A的最新快照(C4)、B的最新快照(C5)和他们的共同祖先(C2)来参与合并。<br><img src="https://git-scm.com/book/en/v2/images/basic-branching-6.png" alt="三方合并"><br>通常地，为了尽可能减少冲突，更推荐使用快进式合并，但在协作中往往会遇到三方合并的情景，为了减轻协作中远端维护人员的合并压力，一个常用的思路是：本地通过变基rebase来变更分支B的祖先，再由远端维护人员将B快进合并到A中。</li></ul><h3 id="3-3变基-rebase"><a href="#3-3变基-rebase" class="headerlink" title="3.3变基(rebase)"></a>3.3变基(rebase)</h3><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><p>rebase 的基本思路是将某一分支的修改全部应用于令一分支，与合并带来的最终结果相同(都整合了来自不同分支的修改)，但是维护了快照(记录)历史的线性关系。<br>仍然是B作为A的分支，要将B的修改整理到A上，可以：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#在B分支中(注意 无需切换到A) 将当前分支的修改 应用到A上 </span><span class="token function">git</span> rebase A<span class="token comment">#删除B分支</span><span class="token function">git</span> checkout A <span class="token function">git</span> branch <span class="token parameter variable">-d</span> B <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在我们的提交记录中，不会有合并的记录，而几乎像是在A分支上线性化地完成了一系列修改，变基维持了历史记录的线性流畅。</p><h4 id="整理历史"><a href="#整理历史" class="headerlink" title="整理历史"></a>整理历史</h4><p>若在本地进行开发时，提交了诸多过于零散的commit，你希望对这些commit 进行合并，你可以使用变基来整理：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#选取最近的三次提交 -i是交互界面</span><span class="token function">git</span> rebase <span class="token parameter variable">-i</span> HEAD~3 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>在交互界面中，我们将要保留的父提交置为<code>pick</code>，将要并入的提交标记为<code>s</code>，保存退出后，将进入提交信息界面，再次保存退出后，即可完成提交合并。</p><h4 id="金科玉律"><a href="#金科玉律" class="headerlink" title="金科玉律"></a>金科玉律</h4><p>变基在很多时候(尤其是协作中)是非常危险的操作，如果想要安全地使用变基，请始终遵循：<strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。</strong><br>其含义是，你的变基所影响的提交范围，只应该是那些你在本地仓库创建且未推送到远程仓库的提交，而不应该对远程仓库中已经存在提交应用变基。</p><h3 id="3-4-贮藏-stash"><a href="#3-4-贮藏-stash" class="headerlink" title="3.4 贮藏(stash)"></a>3.4 贮藏(stash)</h3><p>在多分支工作时，常常需要将当前分支中产生的修改(不想提交的)贮藏起来，实质上相当于将修改先压入临时的”栈空间”中，需要时再取出。</p><h4 id="查看当前的贮藏列表"><a href="#查看当前的贮藏列表" class="headerlink" title="查看当前的贮藏列表"></a>查看当前的贮藏列表</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看全部的贮藏列表</span><span class="token function">git</span> stash  list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h4 id="将当前的修改贮藏"><a href="#将当前的修改贮藏" class="headerlink" title="将当前的修改贮藏"></a>将当前的修改贮藏</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#以下二选一</span><span class="token function">git</span> stash  <span class="token function">git</span> stash push <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="查看某次贮藏的内容"><a href="#查看某次贮藏的内容" class="headerlink" title="查看某次贮藏的内容"></a>查看某次贮藏的内容</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> stash show <span class="token operator">&lt;</span>贮藏标号<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="取出贮藏"><a href="#取出贮藏" class="headerlink" title="取出贮藏"></a>取出贮藏</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#恢复贮藏 但不从列表中删除贮藏 贮藏还能二次恢复(多用于在其他分支应用某一贮藏)</span><span class="token function">git</span> stash apply  <span class="token operator">&lt;</span>贮藏标号<span class="token operator">></span><span class="token comment">#恢复贮藏 并从列表中将其删除（推荐）</span><span class="token function">git</span> stash  pop <span class="token operator">&lt;</span>贮藏标号<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><blockquote><p>后续更新 将持续进行 特别是针对 分布式Git的相关内容。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习归纳</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim 学习整理</title>
    <link href="/posts/e9d4a39f/"/>
    <url>/posts/e9d4a39f/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Vim对于提高编写生产力有很大帮助，笔者正在适应在日常场景下，更多地使用Vim进行代码编写工作，浅浅做整理，以帮助定期温习。本博文持续更新中…..</p></blockquote><h2 id="快捷键汇总"><a href="#快捷键汇总" class="headerlink" title="快捷键汇总"></a>快捷键汇总</h2><ul><li><p>方向控制: <code>h</code>(left)   <code>j</code>(down)   <code>k</code>(up)     <code>l</code>(right)</p></li><li><p>退出当前模式或清空任意已录命令 均可使用<code>ESC</code></p></li><li><p>插入内容:  </p><ul><li><code>i</code> : 在光标之前插入。</li><li><code>I</code>: 在光标所在行的首部之前插入。</li><li><code>a</code> : 在光标之后插入。</li><li><code>A</code>:在光标所在行的尾部之后插入。 </li><li><code>o</code>: 在光标所在行的下方插入一个空行用于编辑。</li><li><code>O(大写)</code>: 在光标所在行的上方插入一个空行用于编辑。</li></ul></li><li><p>删除(剪切)内容:<br>遵照格式 <code>[number]  operator  motion</code>或<code>operator   [number]   motion</code>。删除的operator是<code>d</code>。</p><ul><li><code>dw</code>: w表示从当前光标位置开始执行删除，直到遇到下一个单词或标点。<strong>将光标置于单词首字母，常用来删除整个单词</strong>。</li><li><code>de</code>: e表示从当前光标位置开始执行删除，直到对本单词最后一个字母完成删除为止。</li><li><code>d$</code>:  $表示从当前光标位置开始执行删除，直到本行结束。</li><li><code>dd</code>: 特殊组合，删除当前光标所在行。</li><li><code>x</code>：删除光标当前位置处的字符。</li></ul></li><li><p>修改内容(删除内容并进入编辑模式)：<br>  遵照格式 <code>[number]  operator  motion</code>或<code>operator   [number]   motion</code>。修改的operator是<code>c</code>。 </p><ul><li><code>cw</code>  和 <code>ce</code>效果相同，都可在单词首字符处使用，表示删除该单词并置为编辑模式。</li><li><code>c$</code>:  $表示从当前光标位置开始执行删除，直到本行结束，然后进入编辑模式。</li><li><code>cc</code>: 特殊组合，删除当前光标所在行后进入编辑模式。</li></ul></li><li><p>复制内容:<br>遵照格式 <code>[number]  operator  motion</code>或<code>operator   [number]   motion</code>。复制的operator是<code>y</code>。</p><ul><li><code>yw</code>: w表示从当前光标位置开始执行复制，直到遇到下一个单词或标点。<strong>将光标置于单词首字母，常用来复制整个单词</strong>。</li><li><code>ye</code>: e表示从当前光标位置开始执行复制，直到对本单词最后一个字母完成复制为止。</li><li><code>y$</code>:  $表示从当前光标位置开始执行复制，直到本行结束。</li><li><code>yy</code>: 特殊组合，复制当前光标所在行。</li></ul></li><li><p>粘贴：</p><ul><li><code>p</code>: 在光标之后粘贴一个字符，或在光标所在行下方粘贴(若干)行。</li></ul></li><li><p>撤销修改：</p><ul><li><code>u</code>: 撤销上一个命令带来的修改。</li><li><code>U</code>: 撤销本行的全部修改(可被<code>u</code>撤销)。</li><li><code>Ctrl+R</code>: 恢复上次被<code>u</code>撤销的修改。</li></ul></li><li><p>行与位移：</p><ul><li><code>set nu</code>: 在右侧显示行号。</li><li><code>Ctrl+G</code>: 在底部显示文件名和光标当前位置(所在行&#x2F;全部行 列)。</li><li><code>G</code>: 到文件最后一行。</li><li><code>gg</code>: 到文件的第一行。</li><li><code>:行号</code>: 跳到任意一行。</li></ul></li><li><p>查找：</p><ul><li><code>/+任意内容+回车</code>: 从文件首往下查找匹配的内容。</li><li><code>?+任意内容+回车</code>: 从文件尾往上查找匹配的内容。</li><li><code>n</code>: 查找下一个匹配项。</li><li><code>N</code>: 查找上一个匹配项。</li><li><code>%</code>: 将光标移到括号处，按下<code>%</code>，可以快速找到与当前括号匹配的括号。</li><li><code>0</code>: 到行首。</li><li><code>$</code>: 到行尾。 </li><li><code>w</code>: 移动到下一个单词的首部。</li><li><code>b</code>: 移动到上一个单词的首部。</li><li><code>e</code>: 移动到下一个单词的尾部。</li></ul></li><li><p>替换</p><ul><li><code>r+任意字符</code> 将光标处的字符替换为任意字符。</li><li><code>R</code>: 进入替换模式，等效于Vim帮你常按了r键和光标移动。需要ESC返回正常模式。</li><li><code>:s/old/new/g</code>: 将光标所在行的全部old内容替换为new(g是全部替换)。</li><li><code>:#s/old/new/g</code>: <code>#</code>是行号，最多指定两个行号，彼此用逗号隔开。将指定行的全部old内容替换为new内容(g是全部替换)。</li><li><code>:%s/old/new/gc</code>: 在整个文件范围内将全部old内容替换为new(g是全部替换 c是每次替换都进行确认)。</li></ul></li><li><p>执行外部shell命令：<br>可以在键入<code>:! </code>后，输入任何终端命令，Vim将暂时退返shell终端显示命令结果，稍后只需按下<code>Enter</code>键即可返回Vim。</p><ul><li><code>:!ls </code> 、 <code>:!mkdir xx</code>、 <code>:!rm xx</code>、 <code>:!top</code>等都很常用。</li></ul></li><li><p>文件的写入：</p><ul><li><code>:wq</code>: 保存文件到磁盘并退出。</li><li><code>:x</code>: 更简短的保存文件到磁盘并退出。</li><li><code>:w FileName</code>: 以指定的文件名保存文件到磁盘，等效于文件另存为。特别地，按<code>v</code>进入可视模式，选中若干文本后，再执行该操作，则能实现另存选中文本到指定文件。</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] : <a href="https://csdiy.wiki/%E5%BF%85%E5%AD%A6%E5%B7%A5%E5%85%B7/Vim/">Vim-CS自学指南</a></p><p>[2] : Vimtutor </p>]]></content>
    
    
    <categories>
      
      <category>学习归纳</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TVM实践(一)之TVM安装</title>
    <link href="/posts/86ceff4c/"/>
    <url>/posts/86ceff4c/</url>
    
    <content type="html"><![CDATA[<h2 id="在Linux上从源码安装tvm"><a href="#在Linux上从源码安装tvm" class="headerlink" title="在Linux上从源码安装tvm"></a>在Linux上从源码安装tvm</h2><h3 id="1-拉取源码"><a href="#1-拉取源码" class="headerlink" title="1. 拉取源码"></a>1. 拉取源码</h3><p>先把源代码拉下来，注意使用<code>--recursive</code>可用来获取TVM的依赖(会下载到<code>tvm/3rdparty</code>目录下)：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone <span class="token parameter variable">--recursive</span> https://github.com/apache/tvm tvm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>如果第三方依赖下载过慢，可以在<code>git clone</code>后，进入tvm目录执行下述<strong>命令:</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> submodule init  <span class="token function">git</span> submodule update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h3 id="2-构建准备"><a href="#2-构建准备" class="headerlink" title="2.构建准备"></a>2.构建准备</h3><p>我们的目标是从源码编译得到<code>libtvm.so</code> 和 <code>libtvm_runtime.so</code>。</p><h4 id="2-1-安装依赖"><a href="#2-1-安装依赖" class="headerlink" title="2.1 安装依赖"></a>2.1 安装依赖</h4><p>为保证构建过程顺利完成，我们还需要完成如下依赖的安装：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span>  gcc libtinfo-dev zlib1g-dev build-essential cmake libedit-dev libxml2-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>请确保<code>CMake version &gt;= 3.10 </code>。</p><h4 id="2-2-选择构建工具"><a href="#2-2-选择构建工具" class="headerlink" title="2.2 选择构建工具"></a>2.2 选择构建工具</h4><p>为了更快地增量编译，我们选择使用<code>ninja</code>来进行构建，apt仓库的<code>ninja</code>已完全可用，安装可通过如下命令进行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> ninja<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>安装完成后可通过<code>ninja --version</code>查看。</p><h4 id="2-3-解决python环境"><a href="#2-3-解决python环境" class="headerlink" title="2.3 解决python环境"></a>2.3 解决python环境</h4><p>由于官方文档(0.9.dev0)指出tvm的Python目前仅支持3.8.X+ 和3.7.X+，因此，我们选择使用<code>conda</code>来创建tvm的python环境(conda安装请自行解决)。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda create <span class="token parameter variable">-n</span> tvm <span class="token assign-left variable">python</span><span class="token operator">=</span><span class="token number">3.8</span><span class="token builtin class-name">source</span> activate tvm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h3 id="3-构建配置"><a href="#3-构建配置" class="headerlink" title="3.构建配置"></a>3.构建配置</h3><h4 id="3-1自定义构建选项"><a href="#3-1自定义构建选项" class="headerlink" title="3.1自定义构建选项"></a>3.1自定义构建选项</h4><p>在<code>tvm</code>下创建好<code>build</code>目录，构建所需的配置文件可从<code>tvm/cmake/config.cmake</code>中拷贝。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> tvm <span class="token function">mkdir</span> build <span class="token function">cp</span> cmake/config.cmake build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>编辑<code>build/config.cmake</code>来自定义构建选项：</p><ul><li><code>set(USE_CUDA ON)</code> 启用CUDA后端(需要本地安装CUDA&gt;&#x3D;8.0)</li><li>启用<code>set(USE_GRAPH_EXECUTOR ON)</code>、<code>set(USE_PROFILER ON)</code>来帮助debug。</li><li>如果需要debug IRS，则需要<code>set(USE_RELAY_DEBUG ON)</code>并设置环境变量<em>TVM_LOG_DEBUG</em>。  <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">TVM_LOG_DEBUG</span><span class="token operator">=</span><span class="token string">"ir/transform.cc=1,relay/ir/transform.cc=1"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li></ul><h4 id="3-2-安装并启用llvm"><a href="#3-2-安装并启用llvm" class="headerlink" title="3.2 安装并启用llvm"></a>3.2 安装并启用llvm</h4><p>TVM 依赖 LLVM 用于 CPU 代码生成，官方强烈建议在进行构建的时候启用LLVM，且需要 <code>llvm version &gt;= 4.0</code>，而使用<code>apt</code>默认安装的会低于4.0，我们选择前往<a href="https://releases.llvm.org/download.html">llvm官页</a>下载编译好的llvm包(Pre-Built Binaries)。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://github.com/llvm/llvm-project/releases/download/llvmorg-11.0.0/clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>编辑<code>build/config.cmake</code>，修改<code>set(USE_LLVM &lt;your_llvm_path&gt;/bin/llvm-config)</code>。<br>为了后续调试方便，您可以将llvm加入环境变量：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token string">"&lt;your_path>/llvm/bin:<span class="token environment constant">$PATH</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="4-编译构建"><a href="#4-编译构建" class="headerlink" title="4.编译构建"></a>4.编译构建</h3><p>TVM 的默认配置是构建 RELEASE 版本的共享库。如果要构建 DEBUG 版本的，可以使用选项<code>-DCMAKE_BUILD_TYPE=Debug</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> buildcmake <span class="token parameter variable">-DCMAKE_BUILD_TYPE</span><span class="token operator">=</span>Debug <span class="token parameter variable">-G</span> Ninja <span class="token punctuation">..</span>ninja <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>编译成功后，生成的共享库<code>libtvm.so</code>和<code>libtvm_runtime.so</code>位于<code>build</code>目录下。</p><p>查看生成的共享库是否是<code>DEBUG</code>版本，可在构建目录中执行如下命令，看是否有<code>with debug_info</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-shell-session" data-language="shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">file</span> libtvm.so </span></span><span class="token output">libtvm.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, BuildID[sha1]=57549746b04cd3a7cb359e375db427e1b01a63a2, with debug_info, not stripped</span><span class="token command"><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">file</span> libtvm_runtime.so </span></span><span class="token output">libtvm_runtime.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, BuildID[sha1]=0101648081939d9d6b9498d47498121ecd2aba5b, with debug_info, not stripped</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-安装tvmc-TVM命令行工具"><a href="#5-安装tvmc-TVM命令行工具" class="headerlink" title="5. 安装tvmc (TVM命令行工具)"></a>5. 安装tvmc (TVM命令行工具)</h3><h4 id="5-1-安装依赖"><a href="#5-1-安装依赖" class="headerlink" title="5.1 安装依赖"></a>5.1 安装依赖</h4><p>TVM命令行工具<code>tvmc</code>以python包形式存在于克隆的仓库目录<code>tvm/python/tvm/driver</code>下，我们需要安装如下依赖确保<code>tvmc</code>正常运行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> numpy decorator attrs scipy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="5-2-环境变量配置"><a href="#5-2-环境变量配置" class="headerlink" title="5.2 环境变量配置"></a>5.2 环境变量配置</h4><p>为了能使<code>tvmc</code>可以被正确加载，我们需要添加如下环境变量(可写入<code>~/.bashrc</code>等，请依shell类型确定)：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">TVM_HOME</span><span class="token operator">=</span><span class="token operator">&lt;</span>your_clone_path<span class="token operator">></span>/tvm<span class="token builtin class-name">export</span> <span class="token assign-left variable">PYTHONPATH</span><span class="token operator">=</span><span class="token variable">$TVM_HOME</span>/python:<span class="token variable">$&#123;PYTHONPATH&#125;</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">TVM_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$TVM_HOME</span>/build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>注：</p><ul><li>修改<code>PYTHONPATH</code>是为了<code>python</code>能找到<code>tvm.driver.tvmc</code>。</li><li>添加环境变量<code>TVM_LIBRARY_PATH</code>是为了<code>tvmc</code>能找到所需的共享库<code>libtvm.so</code>和<code>libtvm_runtime.so</code>。</li></ul><p>我们可以重启shell或<code>source ~/.bashrc</code>使上述修改立即<strong>生效</strong>。</p><h4 id="5-3运行与别名"><a href="#5-3运行与别名" class="headerlink" title="5.3运行与别名"></a>5.3运行与别名</h4><p>您可以通过下述命令来运行tvmc并查看帮助：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 <span class="token parameter variable">-m</span> tvm.driver.tvmc <span class="token parameter variable">--help</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>为了使用方便，我们可以为shell执行构建命令别名，您可将下述内容写入<code>~/.bashrc</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">tvmc</span><span class="token operator">=</span><span class="token string">'python3 -m tvm.driver.tvmc'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>生效后，我们就可以直接执行<code>tvmc</code>。</p><h3 id="工作参考"><a href="#工作参考" class="headerlink" title="工作参考"></a>工作参考</h3><ul><li><a href="https://tvm.apache.org/docs/">TVM官方手册</a></li><li><a href="https://github.com/apache/tvm">TVM项目源码</a></li><li><a href="https://csstormq.github.io/blog/TVM%20%E7%AF%87%EF%BC%881%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BA%E5%B9%B6%E5%AE%89%E8%A3%85%20TVM">在Ubuntu从源码构建和安装TVM</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习归纳</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TVM</tag>
      
      <tag>Compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU并行编程模式</title>
    <link href="/posts/71fcd42/"/>
    <url>/posts/71fcd42/</url>
    
    <content type="html"><![CDATA[<h2 id="openMP"><a href="#openMP" class="headerlink" title="openMP"></a>openMP</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>OpenMP</strong>（Open Multi-Processing）是一套支持跨平台<strong>共享内存</strong>方式的<strong>多线程并发</strong>的编程API，使用C,C++和Fortran语言；可以在大多数的处理器体系和操作系统中运行，包括Solaris, AIX, HP-UX, GNU&#x2F;Linux, Mac OS X 和 Microsoft Windows。包括一套<strong>编译器指令</strong>、<strong>库</strong>和一些能够影响运行行为的<strong>环境变量</strong>。支持OpenMP的编译器包括<strong>Sun Studio</strong>和<strong>Intel Compiler</strong>，以及开放源码的<strong>GCC</strong>、<strong>LLVM</strong>和<strong>Open64</strong>编译器。</p><p><strong>OpenMP</strong>提供了对并行算法的高层的抽象描述，程序员通过在原始码中加入专用的<strong>pragma</strong>来指明自己的意图，由此编译器可以自动将程序进行并行化，并在必要之处加入同步互斥以及通信。当选择忽略这些<strong>pragma</strong>，或者编译器不支持<strong>OpenMP</strong>时，程序又可退化为通常的程序（一般为串行），程式码仍然可以正常运作，只是不能利用多线程来加速程序执行。</p><p>混合并行编程模型构建的应用程序可以同时使用OpenMP和MPI。</p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>在C&#x2F;C++中，<strong>OpenMP</strong>被实现在库<code>omp.h</code>中，实现并行时需要包含。进行并行执行的代码片段需要使用<strong>预编译指令</strong>进行相应的标记，被指令标记的部分代码片段将由主线程生成一系列的子线程来执行，并由运行时环境将线程分配给不同的处理器。在并行化的代码运行结束后，子线程join到主线程中，并由主线程继续执行程序。</p><p>其基础语法(预编译指令格式)如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">omp <span class="token operator">&lt;</span>directive<span class="token operator">></span> <span class="token punctuation">[</span>clause<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">]</span> clause<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>其中，<strong>directive</strong>是主指令(必选)，有12种：</p><ul><li><p>parallel 代表接下来的代码块将被多个线程并行<strong>各执行</strong>一遍。</p></li><li><p>critical 其后的代码块为<strong>临界区</strong>，<strong>任意时刻</strong>只能被<strong>一个线程</strong>执行。</p></li><li><p>single 之后的程式将只会在<strong>一个线程</strong>（未必是主线程）中被执行，不会被并行执行。</p></li><li><p>master 指定由<strong>主线程</strong>来执行接下来的程式。</p></li><li><p>barrier 线程在此等待，直到所有的线程都执行到此barrier，用来<strong>同步</strong>所有线程。</p></li><li><p>for 用在for循环之前，由多个线程把<strong>for循环</strong>并行化执行，循环变量只能是<strong>整型</strong>。</p></li><li><p>ordered 指定在接下来的代码块中，被并行化的 for循环将依序执行（<strong>sequential loop</strong>）。</p></li><li><p>flush 所有线程对所有共享对象具有<strong>相同的内存</strong>视图（view of memory）。</p></li><li><p>atomic 内存位置将会原子更新（Specifies that a memory location that will be updated atomically）。</p></li><li><p>threadprivate 指定一个变量是线程局部存储（thread local storage）。</p></li><li><p>sections 将接下来的代码块包含将被并行执行的section块。</p></li></ul><p>而<strong>clause</strong>是可选的子项，有13个：</p><ul><li><p>copyin 让threadprivate的变量的值和主线程的值相同。</p></li><li><p>copyprivate 不同线程中的变量在所有线程中共享。</p></li><li><p>default Specifies the behavior of unscoped variables in a parallel region.</p></li><li><p>firstprivate 对于线程局部存储的变量，其初值是进入并行区之前的值。</p></li><li><p>if 判断条件，可用来决定是否要并行化。</p></li><li><p>lastprivate 在一个循环并行执行结束后，指定变量的值为循环体在顺序最后一次执行时取得的值，或者#pragma sections在中，按文本顺序最后一个section中执行取得的值。</p></li><li><p>nowait 忽略barrier的同步等待。</p></li><li><p>num_threads 设定线程数量的数量。默认值为当前计算机硬件支持的最大并发数。一般就是CPU的内核数目。超线程被操作系统视为独立的CPU内核。</p></li><li><p>ordered 使用于 for，可以在将循环并行化的时候，将程式中有标记 directive ordered 的部份依序执行。</p></li><li><p>reduction Specifies that one or more variables that are private to each thread are the subject of a reduction operation at the end of the parallel region.</p></li><li><p>schedule 设定for循环的并行化方法；有 dynamic、guided、runtime、static 四种方法。</p><ul><li><p>schedule(static, chunk_size) 把chunk_size数目的循环体的执行，静态依序指定给各线程。</p></li><li><p>schedule(dynamic, chunk_size) 把循环体的执行按照chunk_size（缺省值为1）分为若干组（即chunk），每个等待的线程获得当前一组去执行，执行完后重新等待分配新的组。</p></li><li><p>schedule(guided, chunk_size) 把循环体的执行分组，分配给等待执行的线程。最初的组中的循环体执行数目较大，然后逐渐按指数方式下降到chunk_size。</p></li><li><p>schedule(runtime) 循环的并行化方式不在编译时静态确定，而是推迟到程序执行时动态地根据环境变量OMP_SCHEDULE 来决定要使用的方法。</p></li></ul></li><li><p><strong>private</strong> 指定变量为线程局部存储。</p></li><li><p><strong>shared</strong> 指定变量为所有线程共享。</p></li></ul><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><p>OpenMP定义了20多个库函数：</p><ol><li><p>在后续并行区域设置线程数。此调用只影响调用线程所遇到的同一级或内部嵌套级别的后续并行区域。说明：此函数只能在串行代码部分调用。</p> <figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">omp_set_num_threads</span><span class="token punctuation">(</span><span class="token keyword">int</span> _Num_threads<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p>返回当前线程数目。说明：如果在串行代码中调用此函数，返回值为1。</p></li></ol>   <figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">omp_get_num_threads</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ol start="3"><li>返回程序的最大可用线程数量。在程序中此处遇到未使用 num_threads() 子句指定的活动并行区域时可使用。说明：可以在串行或并行区域调用，通常这个最大数量由omp_set_num_threads()或OMP_NUM_THREADS环境变量决定.</li></ol>   <figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">omp_get_max_threads</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ol start="4"><li>返回当前线程id.id从1开始顺序编号,主线程id是0.</li></ol>   <figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">omp_get_thread_num</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ol start="5"><li>返回程序可用的处理器数.</li></ol>   <figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">omp_get_num_procs</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ol start="6"><li>启用或禁用可用线程数的动态调整。(缺省情况下启用动态调整.)此调用只影响调用线程所遇到的同一级或内部嵌套级别的后续并行区域.如果 _Dynamic_threads 的值为非零值,启用动态调整;否则,禁用动态调整.</li></ol>   <figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">omp_set_dynamic</span><span class="token punctuation">(</span><span class="token keyword">int</span> _Dynamic_threads<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ol start="7"><li><p>确定在程序中此处是否启用了动态线程调整.启用了动态线程调整时返回非零值;否则,返回零值.</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">omp_get_dynamic</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p>确定线程是否在并行区域的动态范围内执行.如果在活动并行区域的动态范围内调用,则返回非零值;否则,返回零值.活动并行区域是指 IF 子句求值为 TRUE 的并行区域.</p></li></ol>   <figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">omp_in_parallel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ol start="9"><li>启用或禁用嵌套并行操作.此调用只影响调用线程所遇到的同一级或内部嵌套级别的后续并行区域._Nested 的值为非零值时启用嵌套并行操作;否则,禁用嵌套并行操作.缺省情况下,禁用嵌套并行操作.</li></ol>   <figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">omp_set_nested</span><span class="token punctuation">(</span><span class="token keyword">int</span> _Nested<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ol start="10"><li><p>确定在程序中此处是否启用了嵌套并行操作.启用嵌套并行操作时返回非零值;否则,返回零值.</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">omp_get_nested</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li></ol><p>互斥锁操作 嵌套锁操作 功能</p><ol start="11"><li><p>初始化一个（嵌套）互斥锁。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">omp_init_lock</span><span class="token punctuation">(</span><span class="token class-name">omp_lock_t</span> <span class="token operator">*</span>_Lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p>结束一个（嵌套）互斥锁的使用并释放内存。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">omp_destroy_lock</span><span class="token punctuation">(</span><span class="token class-name">omp_lock_t</span> <span class="token operator">*</span>_Lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">omp_destroy_nest_lock</span><span class="token punctuation">(</span><span class="token class-name">omp_nest_lock_t</span><span class="token operator">*</span> _Lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li><li><p>获得一个（嵌套）互斥锁.</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">omp_set_lock</span><span class="token punctuation">(</span><span class="token class-name">omp_lock_t</span> <span class="token operator">*</span>_Lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">omp_set_nest_lock</span><span class="token punctuation">(</span><span class="token class-name">omp_nest_lock_t</span><span class="token operator">*</span> _Lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li><li><p>释放一个（嵌套）互斥锁.</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">omp_unset_lock</span><span class="token punctuation">(</span><span class="token class-name">omp_lock_t</span> <span class="token operator">*</span>_Lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">omp_unset_nest_lock</span><span class="token punctuation">(</span><span class="token class-name">omp_nest_lock_t</span><span class="token operator">*</span> _Lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li><li><p>试图获得一个（嵌套）互斥锁,并在成功时放回真（true）,失败是返回假（false）。</p>   <figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">omp_test_lock</span><span class="token punctuation">(</span><span class="token class-name">omp_lock_t</span> <span class="token operator">*</span>_Lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">omp_test_nest_lock</span><span class="token punctuation">(</span><span class="token class-name">omp_nest_lock_t</span><span class="token operator">*</span> _Lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li><li><p>获取wall clock time,返回一个double的数,表示从过去的某一时刻经历的时间,一般用于成对出现,进行时间比较. 此函数得到的时间是相对于线程的,也就是每一个线程都有自己的时间。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token function">omp_get_wtime</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p>得到clock ticks的秒数。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token function">omp_get_wtick</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li></ol><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>可以在不破坏串行代码结构的前提下，通过条件编译来引入omp库和方法。示例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_OPENMP  </span></span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;omp.h></span>  </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span> </span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">omp_get_thread_num</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token number">0</span> </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> </span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> TID <span class="token operator">=</span> <span class="token function">omp_get_thread_num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul><li><p>设置环境变量。需要在增加环境变量<code>export OMP_NUM_THREADS=并行线程数</code>。此处并行的线程数应符合自己电脑的cpu核心数。</p></li><li><p>设置编译选项。必须在编译时增加<code>-fopenmp</code>选项。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-fopenmp</span>  src_file  <span class="token parameter variable">-o</span> excute_file g++ <span class="token parameter variable">-fopenmp</span> src_file <span class="token parameter variable">-o</span> excute_file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li></ul><h4 id="基本试例"><a href="#基本试例" class="headerlink" title="基本试例"></a>基本试例</h4><p><code>vim test.c</code>编写C代码如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;omp.h></span> <span class="token comment">//调用openMP库函数</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/*#pragma omp parallel  是编译指导语句(也称编译指令)     *声明下面的块或单行语句 要并行多线程执行(线程数由环境变量处设置)    */</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">omp parallel  </span></span>    <span class="token punctuation">&#123;</span>        <span class="token comment">/*omp_get_thread_num是运行时函数，用来获取执行该代码的线程号*/</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World and openMP! By thread of %d. \n"</span><span class="token punctuation">,</span> \        <span class="token function">omp_get_thread_num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>执行效果如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-shell-session" data-language="shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">$</span> <span class="token bash language-bash">gcc <span class="token parameter variable">-fopenmp</span> test.c <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span> <span class="token operator">&amp;&amp;</span> ./test </span></span><span class="token output">Hello World and openMP! By thread of 1. Hello World and openMP! By thread of 2. Hello World and openMP! By thread of 3. Hello World and openMP! By thread of 0. </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>编译运行<code>gcc -fopenmp test.c - o test &amp;&amp; ./test</code></p>]]></content>
    
    
    <categories>
      
      <category>学习归纳</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPU</tag>
      
      <tag>parallel</tag>
      
      <tag>openMP</tag>
      
      <tag>Matrix Factorization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记博客迁移</title>
    <link href="/posts/bfd9c6dc/"/>
    <url>/posts/bfd9c6dc/</url>
    
    <content type="html"><![CDATA[<blockquote><p>背景：最近主力平台迁移到了实验室的一台Ubuntu主机。<br>工作：1.希望把博客的本地环境也迁移到Linux上。<br>2.清理之前与主题高耦合的样式，通过npm进行便捷重建与更新。<br>3.在新主机上迁移腾讯的COS。</p></blockquote><h2 id="1-环境安装"><a href="#1-环境安装" class="headerlink" title="1.环境安装"></a>1.环境安装</h2><h3 id="1-1-安装Node-js"><a href="#1-1-安装Node-js" class="headerlink" title="1.1 安装Node.js"></a>1.1 安装Node.js</h3><ul><li><p><strong>node.js</strong>：前往<a href="http://nodejs.cn/download/">官网</a>，<strong>windows</strong>下载<em>msi</em>后傻瓜化安装；<strong>Linux</strong>下载<em>二进制包</em>后解压，并为<code>解压目录/bin</code>下的<strong>node</strong>与<strong>npm</strong>文件在<code>/usr/local/bin</code>下创建软链接。在终端检查版本：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /opt/node/node-v16.14.0-linux-x64/bin/node /usr/local/bin/node<span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /opt/node/node-v16.14.0-linux-x64/bin/npm /usr/local/bin/npm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">node</span> <span class="token parameter variable">-v</span> <span class="token function">npm</span> <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li><li><p><strong>cnpm</strong>：由于国外镜像访问速度较慢，推荐安装淘宝定制的包管理器<strong>cnpm</strong>，您可以通过如下命令安装，并在之后的包管理中尽可能使用cnpm：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> cnpm <span class="token parameter variable">--registry</span><span class="token operator">=</span>https://registry.npm.taobao.org <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>并为<code>node安装目录/bin</code>下的<strong>cnpm</strong>文件在<code>/usr/local/bin</code>下创建软链接。在终端检查版本：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /opt/node/node-v16.14.0-linux-x64/bin/cnpm /usr/local/bin/cnpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cnpm <span class="token parameter variable">-v</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li></ul><h3 id="1-2-安装Hexo"><a href="#1-2-安装Hexo" class="headerlink" title="1.2 安装Hexo"></a>1.2 安装Hexo</h3><p><a href="https://hexo.io/zh-cn/">Hexo</a>是一款快速、简洁且高效的静态博客框架。</p><ul><li><p>使用npm包管理器安装hexo模块及脚手架：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p>并为<code>node安装目录/bin</code>下的<strong>hexo</strong>文件在<code>/usr/local/bin</code>下创建软链接。在终端检查版本：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /opt/node/node-v16.14.0-linux-x64/bin/hexo /usr/local/bin/hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo <span class="token parameter variable">-v</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li></ul><br/><h2 id="2-博客部署"><a href="#2-博客部署" class="headerlink" title="2.博客部署"></a>2.博客部署</h2><h3 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h3><p>在本地新建博客目录后，使用hexo进行初始化。</p>  <figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> blogForHexo<span class="token builtin class-name">cd</span> blogForHexohexo init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="2-2安装主题"><a href="#2-2安装主题" class="headerlink" title="2.2安装主题"></a>2.2安装主题</h3><p><a href="https://fluid-dev.github.io/hexo-fluid-docs/">Fluid</a>是一款 Material Design 风格的 Hexo 博客主题。<br>在初始化完成后，可以使用<code>npm</code>安装<code>Fluid</code>主题。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">--save</span> hexo-theme-fluid <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="2-3安装必要插件"><a href="#2-3安装必要插件" class="headerlink" title="2.3安装必要插件"></a>2.3安装必要插件</h3><ul><li><p><a href="https://github.com/Rozbo/hexo-abbrlink">Hexo-abbrlink</a>是一款可以生成唯一永久文章链接的hexo插件。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-abbrlink <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p><a href="https://github.com/hexojs/hexo-deployer-git">Hexo-deployer-git</a>是一款帮助你将hexo博客静态托管到GithubPage的插件。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p><a href="https://github.com/julydate/hexo-static-cos">Hexo-static-cos</a>是一款可以使用腾讯云对象储存和CDN加速hexo博客静态资源访问的插件，感谢<a href="http://www.julydate.com/">七夏</a>大佬提供的思路和支持。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-static-cos <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p><a href="https://github.com/fizker/minifier">minifier</a>是一个无需大量设置即可缩小 CSS&#x2F;JS 的简单工具。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> minifier<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li></ul><h3 id="2-4资源迁移"><a href="#2-4资源迁移" class="headerlink" title="2.4资源迁移"></a>2.4资源迁移</h3><p>我们复制之前博客的<code>source</code>目录、hexo配置文件<code>_config.yml</code>、主题配置文件<code>_config.fluid.yml</code>，覆盖到当前的博客目录中。</p><h2 id="3-腾讯COS"><a href="#3-腾讯COS" class="headerlink" title="3.腾讯COS"></a>3.腾讯COS</h2><h3 id="3-1-安装COS-Browser"><a href="#3-1-安装COS-Browser" class="headerlink" title="3.1 安装COS-Browser"></a>3.1 安装COS-Browser</h3><p><strong>COSBrowser</strong>是腾讯云对象存储 COS 推出的可视化界面工具，让您可以使用更简单的交互轻松实现对 COS 资源的查看、传输和管理。<br>前往<a href="https://cloud.tencent.com/document/product/436/11366">官方手册页</a>，选择<strong>桌面端-Linux</strong>，官方已经支持了<a href="https://appimage.org/">AppImage</a>格式，直接解压后移动到软件目录，并建立到<code>/usr/local/bin</code>的软链接:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> +x cosbrowser.AppImage<span class="token function">mkdir</span> /opt/tencrntCosBrowser<span class="token function">mv</span> ./cosbrowser.AppImage  /opt/tencrntCosBrowser/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /opt/tencrntCosBrowser/cosbrowser.AppImage /usr/local/bin/cosbrowser<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="3-2-为COS-Browser创建桌面启动"><a href="#3-2-为COS-Browser创建桌面启动" class="headerlink" title="3.2 为COS-Browser创建桌面启动"></a>3.2 为COS-Browser创建桌面启动</h3><p>在用户的应用目录中建立<code>.desktop</code>文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.local/share/applications/cosbrowser.desktop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>文件内容如下(图标是从windows里偷的)：</p><figure><div class="code-wrapper"><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">Desktop Entry</span><span class="token punctuation">]</span></span><span class="token key attr-name">Encoding</span><span class="token punctuation">=</span><span class="token value attr-value">UTF-8</span><span class="token key attr-name">Name</span><span class="token punctuation">=</span><span class="token value attr-value">Tecent_COS_Browser</span><span class="token key attr-name">Exec</span><span class="token punctuation">=</span><span class="token value attr-value">cosbrowser</span><span class="token key attr-name">Icon</span><span class="token punctuation">=</span><span class="token value attr-value">~/.local/share/icons/cosbrowser.png</span><span class="token key attr-name">Terminal</span><span class="token punctuation">=</span><span class="token value attr-value">false</span><span class="token key attr-name">Type</span><span class="token punctuation">=</span><span class="token value attr-value">Application</span><span class="token key attr-name">Categories</span><span class="token punctuation">=</span><span class="token value attr-value">Internet</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>保存文件后，即可在应用中搜索到<code>Tecent_COS_Browser</code>，可以将其放到桌面或固定到收藏栏。</p><h3 id="3-3-设置图片目录同步"><a href="#3-3-设置图片目录同步" class="headerlink" title="3.3 设置图片目录同步"></a>3.3 设置图片目录同步</h3><p>打开<code>Tecent_COS_Browser</code>，登陆以后，单击界面右上方的<strong>工具箱&gt;文件同步</strong>，参照下图进行配置：<br><img src="/img/article/3/tongbu.png" alt="tongbu"><br>自动同步设置完成后，每次图片目录的变动都将直接同步覆盖到腾讯云的存储桶中。</p><h2 id="4-博客项目运行"><a href="#4-博客项目运行" class="headerlink" title="4.博客项目运行"></a>4.博客项目运行</h2><h3 id="4-1-本地测试"><a href="#4-1-本地测试" class="headerlink" title="4.1 本地测试"></a>4.1 本地测试</h3><p>每次执行<code>hexo clean</code> 清除<code>public</code>的内容，执行<code>hexo g</code>生成静态资源，执行<code>hexo s</code>进行本地服务部署，而后可打开<code>localhost:4000</code>查看。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean <span class="token operator">&amp;&amp;</span> hexo g <span class="token operator">&amp;&amp;</span> hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="4-2-Github-Page远程部署"><a href="#4-2-Github-Page远程部署" class="headerlink" title="4.2 Github-Page远程部署"></a>4.2 Github-Page远程部署</h3><p>在安装<code>hexo-deployer-git</code>插件后，在<code>_config.yml</code>中配置如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">'git'</span>  <span class="token key atrule">repo</span><span class="token punctuation">:</span> <span class="token string">'git@github.com:VictoryHero/VictoryHero.github.io.git'</span>  <span class="token key atrule">branch</span><span class="token punctuation">:</span> <span class="token string">'gh-pages'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>执行如下命令，更新Public后，自动部署的GitPage：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean <span class="token operator">&amp;&amp;</span> hexo g <span class="token operator">&amp;&amp;</span> hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="4-3-腾讯云静态托管"><a href="#4-3-腾讯云静态托管" class="headerlink" title="4.3 腾讯云静态托管"></a>4.3 腾讯云静态托管</h3><p>首先，我们参考腾讯云社区<a href="https://cloud.tencent.com/document/product/876/47006">博文</a>，在<a href="https://console.cloud.tencent.com/tcb/env/index">云开发控制台</a>完成环境注册。</p><p>其次，安装云开发的CLI工具(CloudBase CLI)。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cnpm i <span class="token parameter variable">-g</span> @cloudbase/cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>  并为<code>node安装目录/bin</code>下的<strong>tcb</strong>文件在<code>/usr/local/bin</code>下创建软链接。在终端检查版本：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /opt/node/node-v16.14.0-linux-x64/bin/tcb /usr/local/bin/tcbtcb <span class="token parameter variable">-v</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>接下来，我们执行以下命令，在弹出的网页中完成对CLI工具的授权。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcb login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>然后，在博客目录中重新生成静态文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean <span class="token operator">&amp;&amp;</span> hexo g   <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>最后将生成的静态文件部署到云开发平台，进行静态托管(环境ID填写自己的)：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcb hosting deploy public <span class="token parameter variable">-e</span> <span class="token punctuation">[</span>EnvID<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>经验整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda 学习整理</title>
    <link href="/posts/5e277129/"/>
    <url>/posts/5e277129/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写在开篇，本文内容基于Windows平台，仅供日常使用参考，若您希望进行系统化的Anaconda学习请移步<a href="https://docs.conda.io/">官方文档</a>。</p><p>如果您机器的环境已经紊乱，建议：</p><ul><li><p>对本机上各版本的python、Anaconda进行一次完全卸载；推荐采用强力的卸载工具Geek。在geek中搜索python和Anaconda，右键卸载即可。geek下载链接在这里：<a href="https://geekuninstaller.com/">https://geekuninstaller.com/</a></p></li><li><p>仔细检查环境变量中 <strong>用户变量</strong>及<strong>系统变量</strong>中的<strong>path</strong>变量，将其中所有包含“python”、“anaconda”的变量全部删除。</p><p>完成后，确保在命令提示窗执行python、pip及conda均是未找到命令。</p></li><li><p>重启计算机后，开始按照如下指导进行环境的重新搭建工作。</p></li></ul></blockquote><h2 id="1-Anaconda安装"><a href="#1-Anaconda安装" class="headerlink" title="1. Anaconda安装"></a>1. Anaconda安装</h2><blockquote><p><strong>Anaconda</strong> Individual Edition is a <strong>Python&#x2F;R</strong> data science distribution and a <strong>collection</strong> of over 7,500+ <strong>open-source packages</strong>, which includes <strong>a package and environment manager</strong>.</p><p>Anaconda(个人版)是一个 python&#x2F;R的数据科学发行版本，它涵盖了超过7500个开源包，其中包括了包管理器和环境管理器。</p><p>通常情况下，在windows上我们单独安装Anaconda即可，无需通过官源额外安装python。最佳策略是<strong>仅仅安装包含最常用python版本的Anaconda，其余版本python使用环境管理。</strong></p><p><strong>注意：</strong>Anaconda包含的解释器只是针对base环境下而言的，虚拟环境不受限制。换言之，包含python3.7的Anaconda也可以创建python3.9的虚拟环境~</p></blockquote><p>出于一定考量，我选择了<strong>包含python3.7解释器的Anaconda3-5.3.0</strong>。各版本的Anaconda安装包我们可以在国内源站找到，笔者用了清华镜像站。也可以在官方下载列表中找到Anaconda-python对应关系及历史版本下载。</p><ul><li><a href="https://docs.anaconda.com/anaconda/packages/oldpkglists/">Anaconda官方站</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">Anaconda清华镜像站</a></li></ul><p>下载好后进行安装，注意如下几点：</p><ul><li>安装位置尽量选在有一定空间(不小于30G保留空间)的磁盘中(不太建议在C盘，因为windows系统中<strong>Conda的base环境以及默认新建环境</strong>都是在安装目录下存放)；安装目录中最好不要出现中文以及空格。</li><li>勾选将Anaconda加入环境变量、注册Anaconda为默认的python解释环境。</li></ul><p>等待安装完成后，我们可以在命令窗口中输入如下命令进行相关性安装结果检测。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python <span class="token parameter variable">--version</span>       <span class="token comment">#检测python是否加入环境变量 </span>conda <span class="token parameter variable">-V</span>       <span class="token comment">#检测conda是否正常   </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>此处额外介绍一个检查conda中是否安装某包的命令：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda list 包名$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda list Spyder$conda list jupyter$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>不指定包名将列出当前conda的全部包。</p><h2 id="2-Conda环境管理"><a href="#2-Conda环境管理" class="headerlink" title="2.Conda环境管理"></a>2.Conda环境管理</h2><blockquote><p>这里笔者希望能谈一谈为什么我们要使用anaconda。大多数情况下，似乎电脑上的python-base环境加一个pip几乎能解决所有问题；但对于面向机器学习、大数据方向的开发及科研人员而言，他们往往会面对复杂的包环境，多个项目对同一个包的版本要求可能存在很大差异(特别是一些图形处理类的包)，一个包的失配带来一个项目瘫痪的连锁反应并不是玩笑之谈。另一方面，我们可能有使用多版本python的需求，如果在一台电脑安装多个解释器，有可能引入一些混乱因素，破坏已有环境。</p><p>因此，我们建议用户养成环境管理的良好习惯。而Anaconda恰好提供了这一功能，你尽可能地为每一个项目都建立独立的环境(当然在熟悉以后你可以按照包的类型和版本建立属于自己的环境template)，它可以是不同的python解释器环境，也可以是不同的包环境(不同版本、不同类型)，且不同环境间各自互不干扰。</p><p>诚然，在开始使用多环境管理时，你会感到非常糟糕，特别是对于长期使用windows的用户而言(Linux多用户情形是天然的环境管理)，但请坚信养成这样的习惯将会使你在从事复杂工作时受益匪浅，更有可能在未来某次任务中为你带来“救赎”，Anaconda不会辜负你。</p></blockquote><h3 id="2-0基础环境-base-x2F-root"><a href="#2-0基础环境-base-x2F-root" class="headerlink" title="2.0基础环境(base&#x2F;root)"></a>2.0基础环境(base&#x2F;root)</h3><p>进入正文，我们打开命令提示窗，首先查看当前的conda 环境。默认情况下，您只有一个root环境，也就是我们最基础的python-base环境，在不激活其他环境的情况下，您的任何操作都将应用到该环境中。另外，您可以看到在环境名后有一个<strong>星号</strong>，星号指定了您当前处于哪一个环境中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">env</span> list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>此外，您也可以使用下述官方推荐命令查看环境:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda info <span class="token parameter variable">--envs</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="2-1创建环境"><a href="#2-1创建环境" class="headerlink" title="2.1创建环境"></a>2.1创建环境</h3><p>命令<code>conda create</code>可以创建环境。</p><h4 id="2-1-1-指定环境名创建-最简方式"><a href="#2-1-1-指定环境名创建-最简方式" class="headerlink" title="2.1.1 指定环境名创建(最简方式)"></a>2.1.1 指定环境名创建(最简方式)</h4><p>我们来创建第一个环境，<code>-n</code>或<code>--name</code>可以指定环境名，这里环境名(英文)尽量贴合项目内容或者主要包的版本。诸如(t1100k224 表示该环境中tensorflow是1.10.0 keras是2.2.4)。起名法则千万条，自己看懂第一条。 可能会提示您确认新增包，按y 回车即可。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda create <span class="token parameter variable">-n</span> tk11 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>创建好环境后，如果您可以通过<code>conda env  list</code>看到您刚才创建的环境，我们通过以下命令激活环境。环境激活后，您可以看到命令提示符最左侧将出现(环境名)，表示您当前的包操作及代码运行环境都将基于该环境。</p><h4 id="2-1-2指定名字与py版本-最常用方式"><a href="#2-1-2指定名字与py版本-最常用方式" class="headerlink" title="2.1.2指定名字与py版本(最常用方式)"></a>2.1.2指定名字与py版本(最常用方式)</h4><p>我们来创建一个包含3.7.0解释器的环境，这也是通常意义上最常用的方式。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda create <span class="token parameter variable">-n</span> tk11 <span class="token assign-left variable">python</span><span class="token operator">=</span><span class="token number">3.7</span>.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>通常情况下，如果不指定pytohn的版本，将默认”克隆”一个base环境，指定后则是为您创建一个全新的基于该版本python的最简环境。</p><h4 id="2-1-3-指定环境完整路径-最省空间方式"><a href="#2-1-3-指定环境完整路径-最省空间方式" class="headerlink" title="2.1.3 指定环境完整路径(最省空间方式)"></a>2.1.3 指定环境完整路径(最省空间方式)</h4><p>我们可以使用<code>-p</code>或<code>--prefix</code>指定环境存放的完整路径。笔者习惯在空间富足的盘中建立一个专用目录统一存放环境，以<code>python版本\环境名</code>作子目录规划。</p><p>下面命令将创建环境，并指定环境的存放目录是<code>D:\AnaEnv\3.7\tk11</code>，该环境<strong>没有“名字”</strong>，此后匹配该环境的操作(例如：激活、删除环境)都<strong>需要使用完整路径</strong>。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda create <span class="token parameter variable">-p</span> D:<span class="token punctuation">\</span>AnaEnv<span class="token punctuation">\</span><span class="token number">3.7</span><span class="token punctuation">\</span>tk11   <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><strong>特别注意：</strong></p><ul><li>官方手册中提及<code>This command requires either the -n NAME or -p PREFIX option.</code>，即<code>conda create</code><strong>必须指定</strong><code>-n</code>环境名或<code>-p</code>存放位置，且<strong>二者不能同时存在</strong>。</li><li>二者差异：<code>-n</code>在Anaconda安装目录下的envs目录中创建与环境同名的目录，来存放该环境，匹配环境时用户使用环境名，Anaconda将在<code>安装目录\envs\</code>下匹配环境；而<code>-p</code>则是由用户指定环境的完整位置，匹配环境时用户需要指定完整的环境位置。</li><li>疑惑：官方何不指定一种同时设置环境名和存放位置的命令模式？</li></ul><h4 id="2-1-4克隆本地环境"><a href="#2-1-4克隆本地环境" class="headerlink" title="2.1.4克隆本地环境"></a>2.1.4克隆本地环境</h4><p>我们可以使用<code>--clone</code>来创建一个新环境，并且克隆某个本地环境的配置。该参后接环境名或环境完整路径。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda create <span class="token parameter variable">-n</span> tk11Sub <span class="token parameter variable">--clone</span> D:<span class="token punctuation">\</span>AnaEnv<span class="token punctuation">\</span><span class="token number">3.7</span><span class="token punctuation">\</span>tk11  conda create <span class="token parameter variable">-n</span> tk11Sub <span class="token parameter variable">--clone</span> tk11   <span class="token comment">#等同于指定 安装目录\envs\tk11</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h4 id="2-1-5从文件中创建"><a href="#2-1-5从文件中创建" class="headerlink" title="2.1.5从文件中创建"></a>2.1.5从文件中创建</h4><p>如果您使用过<code>pip install -r requirements.txt</code>，那这一方式您应该较为熟悉。我们可以使用–file 来指定从他人共享的环境文件读取配置，创建环境。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda create <span class="token parameter variable">-n</span> <span class="token builtin class-name">test</span> <span class="token parameter variable">--file</span> env.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>创建环境文件的方式也很简单，考虑到windows文件可读性建议您创建为yml(实际上后缀名随意)：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">env</span> <span class="token builtin class-name">export</span> <span class="token operator">></span> 环境文件名.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>让我们来看下环境文件的简易版格式：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> myConda <span class="token comment">#环境名</span><span class="token key atrule">channels</span><span class="token punctuation">:</span>   <span class="token comment">#镜像源 </span>  <span class="token punctuation">-</span> defaults  <span class="token key atrule">dependencies</span><span class="token punctuation">:</span> <span class="token comment">#环境中安装的包</span>  <span class="token punctuation">-</span> alabaster=0.7.12=pyhd3eb1b0_0  <span class="token comment">#通过conda安装的包</span>  <span class="token punctuation">-</span> appdirs=1.4.4=pyhd3eb1b0_0  <span class="token punctuation">...</span><span class="token punctuation">...</span>  <span class="token punctuation">-</span> <span class="token key atrule">pip</span><span class="token punctuation">:</span>          <span class="token comment">#通过pip安装的包</span>    <span class="token punctuation">-</span> absl<span class="token punctuation">-</span>py==1.0.0    <span class="token punctuation">-</span> aiohttp==3.8.1    <span class="token punctuation">...</span><span class="token punctuation">...</span><span class="token key atrule">prefix</span><span class="token punctuation">:</span> C<span class="token punctuation">:</span>\Anaconda\envs\myConda  <span class="token comment">#环境路径</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>熟悉格式之后，我们可以自己修改或编写对应的文件，也就是常说的<strong>环境模板</strong>(<strong>Environment Template</strong>)。</p><h4 id="2-1-6指定包创建"><a href="#2-1-6指定包创建" class="headerlink" title="2.1.6指定包创建"></a>2.1.6指定包创建</h4><p>结合官方手册，笔者将命令<code>conda create</code>归纳为携带两类参数：命名参数(<strong>Named Arguments</strong>)与位置参数(<strong>Positional Arguments</strong>)。</p><ul><li><p>命名参数，即需要指定名字的参数。诸如我们的<code>-n</code> <code>-p</code>，此处补充一个常识：<code>-</code>后跟的参数名是<strong>单字母简称</strong>，<code>--</code>后跟的是长参名(或是完整参数名)。而有些参数名既有简称也有长参，就像<code>-n</code> <code>--name</code>或<code>-p</code> <code>--prefix</code>。</p></li><li><p>位置参数只有一个 <strong>package_spec</strong>,即不需要名字的参数，但在位置上有要求，对于本条命令，<strong>您务必保证package_spec 连贯出现</strong>，我们建议您在命令末端使用该参数。本参数特指您在该环境新建时希望加入的包(还可指定包的等级，类比安装包)，我们此前的<code>python=3.7.0</code>就是用例。下面将创建一个包含python3.6和reuquests的抓包环境：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda create <span class="token parameter variable">-n</span> catchPack <span class="token assign-left variable">python</span><span class="token operator">=</span><span class="token number">3.6</span>.1 requests<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li></ul><h3 id="2-2-删除环境"><a href="#2-2-删除环境" class="headerlink" title="2.2 删除环境 "></a>2.2 删除环境<span id="del"> </span></h3><p>目前conda并未提供环境删除的专用命令，我们多通过包删除命令来完成。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda remove <span class="token parameter variable">-n</span> 环境名 <span class="token parameter variable">--all</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="2-3-激活与退出环境"><a href="#2-3-激活与退出环境" class="headerlink" title="2.3 激活与退出环境"></a>2.3 激活与退出环境</h3><p>环境激活：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">activate tk11                 <span class="token comment">#环境名</span>activate D:<span class="token punctuation">\</span>AnaEnv<span class="token punctuation">\</span><span class="token number">3.8</span><span class="token punctuation">\</span>tk12   <span class="token comment">#完整路径</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>环境退出(在当前环境中)：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deactivate           <span class="token comment">#退出当前环境 返回上一层</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="2-4-更多学习"><a href="#2-4-更多学习" class="headerlink" title="2.4 更多学习"></a>2.4 更多学习</h3><p>我推荐您通过以下方式(同其他命令)进行<code>conda</code>的个性化学习：</p><ul><li>您可以使用 <code>-h</code>来便捷查看某命令的其他用法。</li><li>您可以访问官方手册的<a href="https://docs.conda.io/projects/conda/en/latest/commands.html">Command Reference</a>来更友好地学习conda。</li></ul><h2 id="3-Conda-包管理"><a href="#3-Conda-包管理" class="headerlink" title="3.Conda 包管理"></a>3.Conda 包管理</h2><h3 id="3-0-pip与conda区别"><a href="#3-0-pip与conda区别" class="headerlink" title="3.0 pip与conda区别"></a>3.0 pip与conda区别</h3><blockquote><p>介绍包管理，就绕不开官方包管理器pip与(强大)conda的区别，笔者结合查询所得，做了一些<del>归纳</del>搬用，如果您希望获得更原汁原味的讲解，强烈安利<a href="https://www.anaconda.com/blog/understanding-conda-and-pip">官方答疑</a>！</p></blockquote><p>conda和pip尽管在功能上有重叠，但这两款工具是出于不同目的设计的。</p><ul><li>pip是<a href="https://www.pypa.io/en/latest/">Python Packaging Authority (PyPA)</a>团队推荐的用于从<a href="https://pypi.org/">Python Package Index (PyPI)</a>安装包的工具。<ul><li>pip安装的是wheels文件或者源码形式的python软件包，安装源码包时需要配套的编译器(有的还需要一些库)辅助pip完成安装；通常在使用pip前我们需先安装python解释器。</li><li>pip没有内置环境管理，必须依赖<a href="https://virtualenv.pypa.io/en/latest/">virtualenv</a>或<a href="https://docs.python.org/3/library/venv.html">venv</a>等其他工具来创建隔离环境。 <a href="https://pipenv.readthedocs.io/en/latest/">pipenv</a>, <a href="https://poetry.eustace.io/">poetry</a>和<a href="https://github.com/ofek/hatch">hatch</a>等工具将pip和virtualenv封装起来提供了统一的包管理和环境管理功能。</li><li>pip以递归、串行循环的方式安装依赖项，无法确保所有包同时满足依赖，特别当前后安装的包存在版本不相容的依赖时，环境可能会被破坏。</li></ul></li><li>conda是跨平台的包和环境管理器，可以安装和管理来自<a href="https://repo.anaconda.com/">Anaconda repository</a>和<a href="https://anaconda.org/">Anaconda Cloud</a>的conda包。<ul><li>conda包是二进制文件，无需编译器支持，conda可以直接安装Python包以及Python解释器。conda安装包可能包含用其他语言编写的软件的包，包括但不限于C或C ++库，R包或其他软件。</li><li>conda能够创建可以包含不同版本的Python或其他软件包的隔离环境。</li><li>conda在安装包时采用了一个可满足性(SAT) 求解器来检查当前环境中安装的全部包的全部依赖是否能够满足，这一过程会耗费额外的时间，但能保护环境免遭破坏。</li></ul></li><li>Anaconda则将pip和conda结合起来用以创建数据科学环境。主要原因是：有相当一部分包只在PyPI上分发，只能通过pip来安装。Anaconda仓库中涵盖1500多个软件包加上第三方Anaconda Cloud(主要是<a href="https://conda-forge.org/">conda-forge</a> 和<a href="https://bioconda.github.io/">bioconda</a>)中提供的数千个软件包，相比于PyPI上 150,000多个软件包仍然是相形见绌。</li></ul><p>更形象简洁的表述，笔者建议您移步<a href="https://www.anaconda.com/blog/understanding-conda-and-pip">官方答疑</a>。</p><h3 id="3-1包安装"><a href="#3-1包安装" class="headerlink" title="3.1包安装"></a>3.1包安装</h3><h4 id="3-1-1-常规安装"><a href="#3-1-1-常规安装" class="headerlink" title="3.1.1 常规安装"></a>3.1.1 常规安装</h4><p><code>conda install</code>用来安装一系列包到指定环境中，多个包之间以空格间隔，可以只指定包名，也可以<code>像bitarry=0.8</code>一样同时指定包名和版本。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> keras tensorflow <span class="token assign-left variable">bitarry</span><span class="token operator">=</span><span class="token number">0.8</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="3-1-2-本地安装"><a href="#3-1-2-本地安装" class="headerlink" title="3.1.2 本地安装"></a>3.1.2 本地安装</h4><p>若您本地存在conda的二进制包，可以之间通过<code>conda install</code>安装，但这种安装不会检测依赖关系，也不应同常规方式混用在一条命令中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> lxml-3.2.0-py27_0.tar.bz2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="3-1-3-从文件中安装"><a href="#3-1-3-从文件中安装" class="headerlink" title="3.1.3 从文件中安装"></a>3.1.3 从文件中安装</h4><p>类似于<code>pip install -r requirements.txt</code>，conda也提供从文件中读取包名和版本进行安装。文件格式与<code>pip</code>所用的requirements.txt相同。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> <span class="token parameter variable">-f</span> requirements.txt <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="3-1-4-版本回退式安装"><a href="#3-1-4-版本回退式安装" class="headerlink" title="3.1.4 版本回退式安装"></a>3.1.4 版本回退式安装</h4><p>使得当前环境的包组回退到上一版本，详细请参照 <a href="#rev">2.3.4 包回退</a>。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> <span class="token parameter variable">--rev</span>  <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>需要注意：</p><ul><li>安装包时，conda会安装指定包及其依赖依赖包，安装前会对所安装的全部包进行环境兼容性检测，无法通过兼容性检测时会报错，不会改变当前环境。</li><li>在不指定包版本时，conda会试图安装最新版的包，为了匹配最新版软件包，conda可能会安装额外的包、甚至<strong>对已安装的包进行更新、升级</strong>。我们可以通过<code>--freeze-installed</code>参数来强制conda在<strong>不更新</strong>当前已安装包的情况下，选择稍旧的包进行安装。</li><li>如果您觉得conda的依赖检测过于耗时，可以使用<code>--no-deps</code>跳过检测(不推荐)。</li></ul><h3 id="3-2-包卸载"><a href="#3-2-包卸载" class="headerlink" title="3.2 包卸载"></a>3.2 包卸载</h3><p>在Anaconda中，无论用户处于何种环境下，只要通过<code>conda install</code>安装的包都会存放在Anaconda主目录的<code>pkgs</code>目录下。当某一环境中需要安装某包时，Anaconda会首先检查pkgs目录，若目录中已存在所需包，则可以直接将该包拷贝到新环境中。</p><blockquote><p>上述拷贝的实际过程：将<code>Anaconda\pkgs\包名\Lib\site-packages</code>下的内容拷贝到<code>Anaconda\envs\环境名\Lib\site-packages</code>目录下。</p></blockquote><h4 id="3-2-1-从环境中删除"><a href="#3-2-1-从环境中删除" class="headerlink" title="3.2.1 从环境中删除"></a>3.2.1 从环境中删除</h4><p>使用 <code>conda remove</code>来卸载环境中的一系列包，可使用<code>-n 环境名</code>或<code>-p 环境路径</code>来指定环境，您也可以使用– all参数来卸载指定环境中的全部包，详见<a href="#del">环境删除</a>。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">conda remove -n tkEnv  numpy <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>需要注意：</p><ul><li>卸载包时，<code>conda remove</code>只会删除该环境下的包，而不会影响<code>pkgs</code>目录下的包。若另一环境要安装该包，仍会优先从<code>pkgs</code>中拷贝。</li><li>与安装相对应的，<code>conda remove</code>会从环境中删除指定包及依赖该包的全部包。换言之，删除包时请务必谨慎检查conda给出的删除列表，以免重要包被卸载。如果希望跳过依赖检测，只删除指定包，可以使用 <code>--force</code>，但会破坏当前环境(不推荐)。</li></ul><p>[存疑：在base环境删除包会如何….]</p><h4 id="3-2-2-从主机上删除"><a href="#3-2-2-从主机上删除" class="headerlink" title="3.2.2 从主机上删除"></a>3.2.2 从主机上删除</h4><p>若要彻底从主机上删除某包，需要使用<code>conda clean</code>命令来清除<code>Anaconda\pkgs</code>中的内容。</p><h3 id="3-3-包搜索"><a href="#3-3-包搜索" class="headerlink" title="3.3 包搜索"></a>3.3 包搜索</h3><h3 id="3-4-包更新"><a href="#3-4-包更新" class="headerlink" title="3.4 包更新"></a>3.4 包更新</h3><h3 id="3-5-包回退"><a href="#3-5-包回退" class="headerlink" title="3.5 包回退  "></a>3.5 包回退 <span id="rev"> </span></h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://docs.anaconda.com/">Anaconda官方文档</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://docs.conda.io/en/latest/">Conda官方文档</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://baike.baidu.com/item/anaconda/20407441">Anaconda百度百科</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.anaconda.com/blog/understanding-conda-and-pip">conda社区：理解conda与pip</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://blog.csdn.net/FrankieHello/article/details/106083428">CSDN conda和pip安装库之间的区别</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习归纳</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Anaconda</tag>
      
      <tag>Conda</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tensorflow前置知识之GPU篇</title>
    <link href="/posts/5b46bc6/"/>
    <url>/posts/5b46bc6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概念辨析"><a href="#1-概念辨析" class="headerlink" title="1.概念辨析"></a>1.概念辨析</h2><blockquote><p>以下内容源于维基百科<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[图形处理器 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/圖形處理器)">[1]</span></a></sup>、Intel官网<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[What Is a GPU? Graphics Processing Units Defined (intel.com)](https://www.intel.com/content/www/us/en/products/docs/processors/what-is-a-gpu.html)">[2]</span></a></sup><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[CPU vs. GPU: What's the Difference? (intel.com)](https://www.intel.com/content/www/us/en/products/docs/processors/cpu-vs-gpu.html)">[4]</span></a></sup>、GamingScan<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[GPU vs Graphics Card Simple Guide\] - GamingScan](https://www.gamingscan.com/gpu-vs-graphics-card/)">[3]</span></a></sup></p></blockquote><h3 id="1-1-什么是GPU"><a href="#1-1-什么是GPU" class="headerlink" title="1.1 什么是GPU"></a>1.1 什么是GPU</h3><ul><li><strong>GPU</strong>(<strong>G</strong>raphics <strong>P</strong>rocessing <strong>U</strong>nit)即图形处理单元，又称显示核心、图形处理器(有时也统称显卡)，最初是一种用来加速图形渲染的专用处理器。</li><li>GPU这一概念是NVIDIA公司在1999年8月发行<strong>GeForce 256</strong>绘图处理芯片时首先提出的，此前计算机中并不将其看作独立的计算单元。</li><li>GPU的特性在于能够同时处理大量数据(准确说是同时进行大量简单运算工作)，这对机器学习、视频剪辑及游戏渲染非常有用。</li></ul><h3 id="1-2-GPU与显卡的区别"><a href="#1-2-GPU与显卡的区别" class="headerlink" title="1.2 GPU与显卡的区别"></a>1.2 GPU与显卡的区别</h3><p>我们经常会将“GPU”和“显卡”这两个词混用，但实际上二者存在细微差别。</p><p>就像主板包含CPU一样，<strong>显卡</strong>更像是一块包含了GPU的内插板(add-in board)。除了GPU芯片外，它还包含了电路板(PCB)、显存、接口电路、散热器等大量组件。显卡经常被看作一块完成图形计算、图像信号转换传输的独立硬件。在台式机中多通过主板上的PCIE(<strong>P</strong>eripheral <strong>C</strong>omponent <strong>I</strong>nterconnect <strong>E</strong>xpress)插槽与计算机其他部分相连。在笔记本中受体积和重量的限制，显卡通常会通过非标准或独特的接口作连接。</p><p>直观地说，GPU是图形处理芯片，而显卡则是你购买的最终成品。但在日常讨论中为了简化，这一界限早已被模糊，<strong>本文其他部分的讨论中也会默认“显卡即GPU”的指代。</strong></p><h3 id="1-3-集成GPU与独立GPU"><a href="#1-3-集成GPU与独立GPU" class="headerlink" title="1.3 集成GPU与独立GPU"></a>1.3 集成GPU与独立GPU</h3><p>GPU通常可以看作有两个基本类型，即IGPU(<strong>I</strong>ntegrated <strong>G</strong>raphics <strong>P</strong>rocessing <strong>U</strong>nit)和DGPU(<strong>D</strong>iscrete <strong>G</strong>raphics <strong>P</strong>rocessing <strong>U</strong>nit)，也就是常说的集显(核显)和独显。</p><ul><li><p>独显位于独立的电路板中，通过主板上的PCIE槽与计算机其他部分相连。所谓的“独立”是指该显卡享有专用的内存(即自带显存)。独显的优势在于性能更强、不消耗系统的存储资源、往往拥有一些专用的加速单元(诸如CUDA)，但价格、功率、体积都更高(大)。</p></li><li><p>集显不在独立的电路板上，通常与CPU一起嵌入芯片，也有少部集成在主板上(2009年后罕见)。集显工作时需要借用一部分内存充当显存。集显的优势在于可以使架构更轻薄、功耗更低、设计成本更低，但受限于空间、显存等方面因素，其性能往往较弱。(据Intel统计)市场上绝大部分显卡都是集显，集显也是轻薄本的主力显卡。随着技术的发展，一些集显也有不弱于低端独显的能力。</p><p>目前，独显领域是AMD和INVIDIA(英伟达)争锋。PC端的集显主要是Intel的Iris Plus和Intel的UHD；而在移动设备端，则是由Qualcomm(高通)和MediaTek(联发科)生产GPU，这些GPU往往和CPU及其他核心移动芯片组组件位于同一芯片中。</p></li></ul><h2 id="2-GPU与CPU"><a href="#2-GPU与CPU" class="headerlink" title="2.GPU与CPU"></a>2.GPU与CPU</h2><h3 id="2-1-GPU的优势"><a href="#2-1-GPU的优势" class="headerlink" title="2.1 GPU的优势"></a>2.1 GPU的优势</h3><p>现如今，GPU已经成为计算机中最重要的部件之一，GPU最初设计用来加速3D图形的渲染，但时至今日，GPU已经被赋予了更多可能性。图形程序员可以利用先进的照明和阴影技术来创造更有趣的视觉效果和真实场景，这为视频剪辑制作、游戏效果带来了全新的体验。而其他开发者也开始利用GPU来大幅加速高性能计算、深度学习等。</p><p>我们常说GPU是为并行处理而设计的，更准确地说法是：<strong>GPU被设计用于图形渲染，更适合完成高计算密度和并行处理场景的任务。</strong>这里借用[《NAVIDIA CUDA Programming Guide》](<a href="https://www.nvidia.cn/docs/IO/51635/NVIDIA_CUDA_Programming_Guide_1.1_chs.pdf">Microsoft Word - CUDA PG 1 1 chs.doc (nvidia.cn)</a>)的一幅图：</p><p><img src="/img/article/1/CPUvsGPU.png" alt="CPUvsGPU"></p><center>图1.4.1 CPU与GPU中晶体管的用途比例</center><p>从上图中可以直观地看到，GPU将更多的晶体管投入到了运算单元(ALU)，而削弱了控制(Control)和高速缓存(Cache)的能力。这就意味着GPU能同时进行更多简单运算，但在面对需要复杂控制电路配合的运算时则有些捉襟见肘。</p><blockquote><p>以下摘录原书中的两段话(适当调整了措辞断句)</p></blockquote><p>GPU 特别适合于并行数据运算的问题——同一个程序存在许多并行数据元素， 并带有高运算密度（算术运算与内存操作的比例）。由于同一个程序要执行每个数据元素(运算差异小)， 降低了对复杂控制的要求;  并且，因为它处理许多数据元素并据有高运算密度，存储访问的延迟也可以被忽略。   </p><p>并行数据处理，意味着数据元素以并行线程的方式处理。许多处理大量数据(例如数组)的应用程序可以使用一个并行数据的编程模型来加速计算。在3D 渲染上，庞大的像素集和顶点被映射到并行线程中；图像和媒体处理中，例如着色的图像后处理、录像编码和解码、 图像缩放比例、立体视觉以及图像识别也可以映射图像块和像素到并行处理线程中。实际上， 图形领域外的许多算法同样可以通过并行数据处理得到加速，从信号处理、物理模拟到金融计算、生物计算乃至深度学习等。</p><h3 id="2-2-CPU的优势"><a href="#2-2-CPU的优势" class="headerlink" title="2.2 CPU的优势"></a>2.2 CPU的优势</h3><p>再来看CPU，它拥有强大的算术运算单元，可以在很短的时钟周期内完成算术运算；CPU有更大、层次更多的高速缓存单元，有效降低了数据访存取带来的指令时延；CPU拥有复杂的逻辑控制单元，能够完成更困难的控制和调度任务(诸如分支预测等)。CPU是天然的leader，也能够更快、更精确地处理复杂指令。而GPU则是以大吞吐量为前提，简化了控制和数据缓存，靠“数量”取胜。</p><h3 id="2-3-CPU与GPU的分工"><a href="#2-3-CPU与GPU的分工" class="headerlink" title="2.3 CPU与GPU的分工"></a>2.3 CPU与GPU的分工</h3><p>笔者很喜欢一个比喻：GPU的运算速度取决于雇了多少小学生，而CPU的运算速度取决于请了多么厉害的教授。一切抛开控制谈算力的讨论，都是“耍流氓”。CPU和GPU没有谁更强，只有不同场景下谁更合适，他们都是基本的计算引擎，彼此分工不同罢了。Intel官网的一篇文章详尽探讨了CPU和GPU的分工，来帮助计算机使用者更好地设计高性能的软件、更好地根据工作类型搭配硬件(原文参考<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[CPU vs. GPU: What's the Difference? (intel.com)](https://www.intel.com/content/www/us/en/products/docs/processors/cpu-vs-gpu.html)">[4]</span></a></sup>)，笔者摘录意译了一部分内容：</p><h4 id="2-3-1-cpu和gpu的区别"><a href="#2-3-1-cpu和gpu的区别" class="headerlink" title="2.3.1 cpu和gpu的区别"></a>2.3.1 cpu和gpu的区别</h4><p>CPU和GPU有很多共同点，他们都是重要的计算引擎，都是基于硅制造的微处理器，都能处理数据，但GPU和CPU有着不同的架构，是为不同的目的而设计的。</p><p>CPU被看作是计算机系统的大脑，它拥有更复杂的控制、存储和计算结构，适用于更广泛的工作任务，特别是存在延迟或更看重单核性能的工作。CPU是一个强大的执行引擎，它将更少的内核集中在单任务和快速处理上，这使得它从串行计算到运行数据库等多方面都具有独特的优势。</p><p>GPU则由许多粒度更小、用途更专一的核组成。当一个处理任务可以在许多核心之间进行分割和处理时，这些核心可以通过协同工作提供巨大的性能。最初的GPU是为加速特定3D渲染任务而设计的专用处理器，但现在已经变得更加灵活且具备了更强的可编程性。虽然GPU的主要功能仍然集中在图形处理和为顶级游戏提供更加逼真的视觉效果，但不可否认GPU已经发展为了更通用的并行处理器。</p><h4 id="2-3-2-加速深度学习和人工智能"><a href="#2-3-2-加速深度学习和人工智能" class="headerlink" title="2.3.2 加速深度学习和人工智能"></a>2.3.2 加速深度学习和人工智能</h4><p>GPU的并行处理和高密度计算优势，使得对于多层神经网络的深度学习模型训练或大量特定数据集(如二维图片)的处理，GPU能提供更理想的加速效果。此外，现在很多深度学习算法都被改编为适用GPU加速的方法。</p><p>时过境迁，CPU和其上运行的软件库也发展地更加适用深度学习。例如因特尔至强系列中的Intel Deep Learning Boost，就是通过优化大量的软件库、增加专用的AI硬件来优化深度学习任务的性能。此外，在一些非图像深度学习任务中(诸如：语言类、文本类、时序数据)，CPU大放异彩；对于复杂的模型或者深度学习应用(诸如二维图像的检测任务)，CPU也能通过提供比GPU大得多的内存来表现出更好的性能。</p><p><strong>From CPU vs. GPU to CPU and GPU !</strong></p><h2 id="3-NVIDIA-GPU系列"><a href="#3-NVIDIA-GPU系列" class="headerlink" title="3. NVIDIA GPU系列"></a>3. NVIDIA GPU系列</h2><p>目前主要的独显厂家是NVIDIA和AMD，限于篇幅我们将着重介绍NVIDIA的显卡系列。</p><blockquote><p>以下内容参考 博文<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[【GPU编程系列之一】从深度学习选择什么样的gpu来谈谈gpu的硬件架构 | 听见下雨的声音 (chenrudan.github.io)](https://chenrudan.github.io/blog/2015/12/20/introductionofgpuhardware.html)">[5]</span></a></sup>  知乎<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="[NVIDIA GPU 架构梳理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/394352476)">[7]</span></a></sup>维基百科<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="[List of Nvidia graphics processing units - Wikipedia](https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units)">[6]</span></a></sup></p></blockquote><p>英伟达的显卡，通常基于<strong>微架构</strong>设计<strong>芯片</strong>，根据<strong>显卡系列</strong>的受众来设计显卡并实装芯片，同一系列当中再进行不同性能等级的硬件定制从而分化出<strong>系列型号或档次</strong>(尤以GeFore系列为例)，在同一型号的同一代中又会通过设计微调来细分性能档次，从而形成了非常严密的系列(性能、价格)递进(也有可能乱序)，被显卡用户戏称为“老黄刀法精确”。这样繁杂的划分(调整)之下，通过显卡命名来判定不同显卡间性能的差异变得比较困难。 </p><h3 id="3-1-GPU微架构"><a href="#3-1-GPU微架构" class="headerlink" title="3.1 GPU微架构"></a>3.1 GPU微架构</h3><p>英伟达的第一款GPU架构致敬摄氏温度，此后则多致敬历史上著名的科学家，截至2021年英伟达总共提出了12种微架构，按照时间先后顺序列出其名称、发布时间及命名致敬：</p><table><thead><tr><th>架构名</th><th>发布时间</th><th>命名致敬</th></tr></thead><tbody><tr><td>Celsius</td><td>1999</td><td>摄氏度(温度单位)</td></tr><tr><td>Kelvin</td><td>2001</td><td>威廉·汤姆森<br/>(开尔文温度提出者)</td></tr><tr><td>Rankine</td><td>2003</td><td>兰金(兰氏温度提出者)</td></tr><tr><td>Curie</td><td>2004</td><td>居里夫人</td></tr><tr><td>Tesla</td><td>2006</td><td>特斯拉</td></tr><tr><td>Fermi</td><td>2010</td><td>费米</td></tr><tr><td>Kepler</td><td>2012</td><td>开普勒</td></tr><tr><td>Maxwell</td><td>2014</td><td>麦克斯韦</td></tr><tr><td>Pascal</td><td>2016</td><td>帕斯卡</td></tr><tr><td>Volta</td><td>2017</td><td>伏打</td></tr><tr><td>Turing</td><td>2018</td><td>图灵</td></tr><tr><td>Ampere</td><td>2020</td><td>安培</td></tr></tbody></table><p>微架构(MicroArchitecture)指的是处理器的设计方式(设计思想)，可以具体到处理器簇中有多少core、是否包含L1或L2缓存、是否有双精度计算单元等等。</p><h3 id="3-2-GPU芯片"><a href="#3-2-GPU芯片" class="headerlink" title="3.2 GPU芯片"></a>3.2 GPU芯片</h3><p>英伟达的显卡芯片命名规则为：<strong>G</strong>(GPU) + <strong>X</strong>(芯片所用架构名的首字母) + <strong>数字</strong>(表示型号)。例如：GT200，表示基于Tesla架构设计的200代(型)芯片。同一架构的芯片设计思路相同，但在细节上会有改变，例如：GK210比GK110的寄存器数目多一倍。 </p><h3 id="3-3-显卡系列"><a href="#3-3-显卡系列" class="headerlink" title="3.3 显卡系列"></a>3.3 显卡系列</h3><p>英伟达将旗下设计的显卡分为三类：GeFore系列(用于家庭娱乐)、Quadro系列(用于工作站)、Tesla系列(用于服务器)。</p><ul><li><p>对于Tesla系列而言，其没有显示输出接口，仅仅专注于数据计算，主要类型：</p><ul><li>K型卡：专注于高性能科学计算，比较突出的优点是具有较高的双精度浮点运算能力，并且支持ECC内存。</li><li>M型卡：专门用于深度学习网络训练的显卡。</li></ul></li><li><p>对于GeFore系列而言，有图形输出接口。</p><ul><li>(仅供了解 不要抬杠)从历史角度来看，GPU的类型(型号)是不同硬件的定制，可以理解为不同性能规格(主要体现在时钟频率和显存的增强)：G&#x2F;GS(入门)  &lt; GT(普通) &lt; GTS(中端) &lt; GTX(高端)。笔者只希望读者了解这段历史，但并不希望读者套用到当下环境中。</li><li>随着时间推移，GeFore型号名开始变成了粗分显卡性能的<strong>前缀词</strong>，当下这个前缀词更是成为了显卡性能或技术的时代标志，例如目前最新的RTX系列，就是因为引入光线追踪技术(<strong>R</strong>ay <strong>T</strong>racing)而得名。它与GTX不能再看作同时代产品的不同硬件定制，而是GeFore系列下不同技术时代的产品，RTX系列表示的是GeFore显卡最新技术和更高性能天花板的产物。</li></ul></li></ul><h3 id="3-4-GeForce显卡命名规则"><a href="#3-4-GeForce显卡命名规则" class="headerlink" title="3.4 GeForce显卡命名规则"></a>3.4 GeForce显卡命名规则</h3><p>以GeForce GTX 1660 Ti为例，英伟达推出的GeForce显卡一般遵循如下命名规则：</p><p> <strong>GeForce</strong>(显卡系列)  <strong>GTX</strong>(显卡前缀) <strong>16</strong>(系列编号或称代数)  <strong>6</strong>(显卡性能档次定位) <strong>0</strong>(末尾数字一般为0 用来补位)   <strong>Ti</strong>(后缀)</p><p>其中要注意：</p><ul><li>代数：英伟达GeForce显卡的代数(系列编号)很不规整，详情参考<a href="#series">1.6.5</a>。</li><li>后缀：没有后缀是正常版、SE后缀是削弱版、Ti后缀是加强版( 一般加Ti的比正常版频率提高30%左右 有测试者称 实际性能提升约20%) 、M后缀一般是笔记本电脑专用等，后缀还有LE、super、pro等，会根据市场情况不定时增减，日常关注有无Ti即可。</li><li>特别的，当命名中存在MX或M字样时，表示该显卡是用在笔记本端的。</li></ul><h3 id="3-5-GeForce系列-完整版"><a href="#3-5-GeForce系列-完整版" class="headerlink" title=" 3.5 GeForce系列(完整版)"></a><span id="series"> </span>3.5 GeForce系列(完整版)</h3><p>思前想后，笔者还是决定专开一栏对GeForce不同代的命名差异做一下整理，下面主要介绍Desktop GPU的GeForce series及他们的一些特点。</p><ul><li><p>GeForce 256：是GPU的开山鼻祖，首次使用Celsius 微架构，始发于1999年，有GeForce 256 SDR和GeForce 256 DDR两款。</p></li><li><p>GeForce2系列：这一系列开始划分出多种型号，始发是2000年的GeForce2 GTS。</p></li><li><p>GeForce3系列：2001年发布的GeForce，首次使用Kelvin架构，是全球第一款支持DX8(Direct3D 8.0)的显卡，游戏福音。</p></li><li><p>GeForce4系列：2002年发布的GeForce4 Ti 4200，支持高效抗锯齿技术(<strong>A</strong>ccuview <strong>A</strong>ntialiasing)，更好的图形显示(游戏画面)效果。是NVIDIA历史上性价比最高的卡。</p></li><li><p>GeForce FX系列：首次使用Rankine架构，采用了更成熟的DDR显存，支持DX9技术，并在多方面做了优化改进，标志英伟达真正意义上的高端显卡出现，首发2003年。</p></li><li><p>GeForce6系列：首次使用Curie架构，除了性能巨大提升，还创造出基于PCIE的SLI(<strong>S</strong>calable <strong>L</strong>ink <strong>I</strong>nterface)模式，在一块支持双PCIE接口的主板上可以同时使用两块同型号的PCIE显卡，首发2004年。</p></li><li><p>GeForce7系列：2005年首发的GTX 7800GT，是首款消费级的双芯显卡，<strong>GTX入场</strong>。</p></li><li><p>GeForce8系列：2007年首发，是首款使用<strong>Tesla微架构芯片</strong>的显卡，<strong>引入了CUDA</strong>。</p></li><li><p>GeForce9系列：2008年首发的GeForce 9600GT，对8系列作了完美改进，提高性能降低功耗。也是GeForceX系列的最后荣光。</p></li><li><p>GeForce 100系列：2009年首发，并且开始使用GeForce G&#x2F;GT&#x2F;GTS来代表不同级别。</p></li><li><p>GeForce 200系列：2009年首发的GTX 280，正式开启了全新的GeForce GTX 200系列，该系列显卡拥有图形处理和并行计算结构体系。</p></li><li><p>GeForce 300系列：2009年11月首发GeForce 310,本系列没有GTX，支持了DX10。</p></li><li><p>GeForce 400系列：2010年首发的GEForce GTX 480，首次支持Fermi架构。</p></li><li><p>GeFroce 500系列：2011年首发的GTX 580中采用完整的Fermi核心(512个流处理器)。</p></li><li><p>GeForce 600系列：2012年首发GTX680，采用全新的Kepler架构和台积电28nm工艺，英伟达显卡突破性地加入了动态加速，年底发布了更强悍的GTX690。</p></li><li><p>GeForce 700系列：2013年首发了<strong>GTX TITAN</strong>、GTX780Ti，由于第一代Kepler架构表现良好，英伟达推出了大核心芯片GK110，并将实装该芯片的显卡命名为TITAN系列，这是首次没采用数字编号命名显卡，也是N卡家族中第一代TITAN，至此TITAN成为了N卡中至强的代表，官网驱动下载页甚至将TITAN看作了与GeFroce并列的系列。</p></li><li><p>GeForce 800系列：抱歉，没有这个系列，又又又跳卡了。</p></li><li><p>GeForce 900系列：2014年首发的GTX 980和GTX 970，采用了全新的Maxwell架构。</p></li><li><p>GeForce 10系列：2016年发布了GTX1080(旗舰)、GTX 1070(高端)、GTX1060(中高端)，采用了全新的Pascal架构，并且工艺达到了16nm，晶体管数量暴增，核心频率大幅提升，超频轻松突破2GHz，带来了GDDR5X显存、异步运算改进、新的VR技术等。在2017年发布的<strong>GTX1080 Ti</strong>更是顶配的Pascal架构显卡，超越了当时最强卡皇TITAN X，成为了<strong>GTX时代的神话卡</strong>。</p></li><li><p>GeForce 20系列(RTX20)：2018年首发的GeForce RTX2080Ti、RTX2070、RTX2060，不仅采用了全新的Turing架构，并且引入了光线追踪技术，也正式宣告了GTX时代的落幕，<strong>20之后再无GTX，RTX代替GTX成为显卡市场主力军。</strong>同年12月，英伟达发布了RTX中的第一块TITAN霸主，全称Nvidia TITAN RTX。</p></li><li><p>GeForce 16系列：2019年发布了GTX 1650、GTX1650Spuer、1660、1660Super、1660Ti，GeForce 16系列是GTX最后的荣光，<strong>是GeForce 20系列的阉割版本，相比10系列提升并不大，但使用的是下一代架构Turing。</strong></p></li><li><p>GeForce 30系列(RTX30)：</p><ul><li>2020年发布的RTX 3090、RTX 3080、RTX3070，采用了全新的Ampere架构，相比RTX20的Turing架构是革命性提升，Ampere集成了第二代RT光线追踪核心、第三代Tensor张量核心。其中的旗舰卡RTX3090搭载了24GB的GDDR6X显存，拥有10496个流处理器，在游戏和深度学习方面带来了前所未有的体验。</li><li>2021年为了调节挖矿对显卡市场的冲击，发布了”锁矿”的RTX 3060，实际效果欠佳，后又删除。</li><li>2021年，为了弥补RTX3090和RTX3080之间的性能差距，于6月份发布了RTX 3080 Ti 和RTX 3070 Ti。</li></ul><h3 id="3-6-显卡天梯图"><a href="#3-6-显卡天梯图" class="headerlink" title="3.6 显卡天梯图"></a>3.6 显卡天梯图</h3><blockquote><p>更多显卡性能的比较，可以搜索2021显卡天梯图 或 gpu hierarchy 2021，下面pull一张来自 百度贴吧<em>秋刀鱼半藏</em> 大佬更新于2021年11月的显卡天梯图。</p><p>详情移步: <a href="https://tieba.baidu.com/p/6133450546?see_lz=1#135699450528l">《史上最全桌面级显卡天梯图》专用更新帖(公测版)_amd吧</a></p></blockquote></li></ul><p><img src="/img/article/1/GPURank.jpg" alt="GPURank"></p><!-- ![GPURank](https://tiebapic.baidu.com/forum/pic/item/75bccbef76094b36e78da4fffecc7cd98d109d92.jpg?tbpicau=2022-03-23-05_9187fba72f56c70f6ee82ae96269ae6c) --><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://zh.wikipedia.org/wiki/%E5%9C%96%E5%BD%A2%E8%99%95%E7%90%86%E5%99%A8">图形处理器 - 维基百科，自由的百科全书 (wikipedia.org)</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.intel.com/content/www/us/en/products/docs/processors/what-is-a-gpu.html">What Is a GPU? Graphics Processing Units Defined (intel.com)</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.gamingscan.com/gpu-vs-graphics-card/">GPU vs Graphics Card Simple Guide] - GamingScan</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.intel.com/content/www/us/en/products/docs/processors/cpu-vs-gpu.html">CPU vs. GPU: What’s the Difference? (intel.com)</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://chenrudan.github.io/blog/2015/12/20/introductionofgpuhardware.html">【GPU编程系列之一】从深度学习选择什么样的gpu来谈谈gpu的硬件架构 | 听见下雨的声音 (chenrudan.github.io)</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units">List of Nvidia graphics processing units - Wikipedia</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/394352476">NVIDIA GPU 架构梳理 - 知乎 (zhihu.com)</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span><a href="https://www.sohu.com/a/470642262_120973764">快速回顾NVIDIA显卡发展史，看看小伙伴们都用过哪些显卡。_GeForce (sohu.com)</a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:9" class="footnote-text"><span><a href="https://tieba.baidu.com/p/6133450546?see_lz=1#135699450528l">《史上最全桌面级显卡天梯图》专用更新帖(公测版)_amd吧</a><a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习归纳</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tensorflow</tag>
      
      <tag>GPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A Free Try For YaCy</title>
    <link href="/posts/7c8dee09/"/>
    <url>/posts/7c8dee09/</url>
    
    <content type="html"><![CDATA[<p>安装最新的java环境</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dnf <span class="token function">install</span> <span class="token parameter variable">-y</span> java-latest-openjdk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>下载YaCy的LinuxTarball</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> http://latest.yacy.net/yacy_v1.922_20191013_9964.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>解压文件到&#x2F;opt目录下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">--extract</span> <span class="token parameter variable">--file</span> yacy_v1.922_20191013_9964.tar.gz <span class="token parameter variable">--directory</span> /opt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>运行YaCy</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">source &#x2F;opt&#x2F;startYACY.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>Success as this:<br><img src="https://img-blog.csdnimg.cn/20200304163821709.png" alt="在这里插入图片描述">Try it!</p>]]></content>
    
    
    <categories>
      
      <category>技术尝鲜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CentOS8</tag>
      
      <tag>YaCy</tag>
      
      <tag>P2P</tag>
      
      <tag>搜索引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ununtu18上安装NCL6.6</title>
    <link href="/posts/7996d43b/"/>
    <url>/posts/7996d43b/</url>
    
    <content type="html"><![CDATA[<blockquote><p>继NCL更新到6.6以后,官网给出了很方便的conda安装，<a href="http://www.ncl.ucar.edu/Download/conda.shtml">详见官网教程</a><br>在这里，笔者整理了一下自己的安装思路。<br>根据官网的推荐，我们选择了minconda而不是Anaconda（小巧够用）</p></blockquote><h2 id="1-安装Minconda"><a href="#1-安装Minconda" class="headerlink" title="1.安装Minconda"></a>1.安装Minconda</h2><h4 id="1-1下载脚本"><a href="#1-1下载脚本" class="headerlink" title="1.1下载脚本"></a>1.1下载脚本</h4><p>从中科大的源站下载minconda安装脚本，并执行。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-4.5.11-Linux-x86_64.sh<span class="token function">chmod</span> +x Miniconda3-4.5.11-Linux-x86_64.sh./Miniconda3-4.5.11-Linux-x86_64.sh <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>脚本执行后，会有一系列交互，提示你设置环境变量、安装位置等等，如果你不想做决定，懒人办法是:回车确认后，阅读条例后按q 第一个出现的选yes 之后统统回车用默认值</p><h4 id="1-2配置环境变量"><a href="#1-2配置环境变量" class="headerlink" title="1.2配置环境变量"></a>1.2配置环境变量</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> .bashrc<span class="token comment">#文件末尾写入</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/home/lb/miniconda3/bin:<span class="token environment constant">$PATH</span><span class="token comment">#:wq保存退出</span><span class="token builtin class-name">source</span> .bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="1-3查看版本"><a href="#1-3查看版本" class="headerlink" title="1.3查看版本"></a>1.3查看版本</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token parameter variable">-v</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="2-安装NCL"><a href="#2-安装NCL" class="headerlink" title="2.安装NCL"></a>2.安装NCL</h2><p>使用conda安装，这将是个漫长的过程</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda create <span class="token parameter variable">-n</span> ncl_stable <span class="token parameter variable">-c</span> conda-forge ncl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>等上面步骤结束后，按照提示激活环境</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> activate ncl_stable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>试着跑一份代码，正常得到图形结果，说明安装成功。<br><img src="https://img-blog.csdnimg.cn/20200303180831758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMTc1ODMyMzY2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200303181222377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMTc1ODMyMzY2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-使用ncl"><a href="#3-使用ncl" class="headerlink" title="3.使用ncl"></a>3.使用ncl</h2><p>此后每次在终端中使用时:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">##激活环境</span><span class="token builtin class-name">source</span> activate ncl_stable<span class="token comment">##关闭环境</span><span class="token builtin class-name">source</span> deactivate <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>经验整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NCL</tag>
      
      <tag>Ubuntu</tag>
      
      <tag>conda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS8部署Cockpit</title>
    <link href="/posts/a584670/"/>
    <url>/posts/a584670/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Cockpit是一个Web控制台，具有易于使用的基于Web的界面，使您可以在服务器上执行管理任务。它也是一个Web控制台，它意味着您也可以通过移动设备访问它。它可以执行多种任务:</p><ul><li>管理服务</li><li>管理用户帐号</li><li>管理和监视系统服务</li><li>配置网络接口和防火墙</li><li>查看系统日志</li><li>管理虚拟机</li><li>创建诊断报告</li><li>设置内核转储配置</li><li>配置SELinux</li><li>更新软件</li><li>管理系统订阅</li></ul></blockquote><p>RHEL8系列集成了Cockpit，除了可以在web中管理、检测Liunx主机以外，不得不说的是还可以通过Cockpit管理台在web中登陆ssh终端哦！笔者迫不及待地去玩耍了一番。<br>cockpit默认监听<strong>9090</strong>端口，记得在安全规则里提前开放哦！<br>如果有运行firewall-cmd 可以执行如下，开放9090端口</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --add-service<span class="token operator">=</span>cockpit <span class="token parameter variable">--permanent</span>firewall-cmd <span class="token parameter variable">--reload</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> cockpit.socket <span class="token comment">#配置开机启动cockpit服务，并现在开启</span><span class="token function">lsof</span> <span class="token parameter variable">-i:9090</span><span class="token comment">#查看9090端口当前的监听者</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>登陆浏览器，键入 公网地址:9090 并回车<br>此时浏览器多会提示证书风险，可以选择高级-&gt;继续访问</p><blockquote><p>控制台是从&#x2F;etc&#x2F;cockpit&#x2F;ws-certs.d下调用证书的 如果没有安装正规机构颁发的证书，将默认采用自签发证书，故而会被风险警告</p></blockquote><p>接着，便会进入一个登陆界面:<br><img src="https://img-blog.csdnimg.cn/20200304132716355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMTc1ODMyMzY2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>输入账号密码登陆以后，进入系统管理界面:<br><img src="https://img-blog.csdnimg.cn/20200304132744774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMTc1ODMyMzY2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>用cockpit管理主机对运维相当友好哦！<br>介于管理系统暴露在公网下风险较大，可以尝试修改监听端口、日常停用服务只在使用时开启等。</p>]]></content>
    
    
    <categories>
      
      <category>技术尝鲜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CentOS8</tag>
      
      <tag>Cockpit</tag>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS8后端开发环境(LNMP)部署</title>
    <link href="/posts/95e2d64f/"/>
    <url>/posts/95e2d64f/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言:笔者通过阿里云的学生”<a href="https://developer.aliyun.com/adc/student/#ecscolleges-collocation-stu">在家实践计划</a>“获得了一台2核4G的云ECS实例，并安装了Centos8镜像。于是尝试部署一套Django的生产环境。笔者选择了  Nginx + uwsgi + mysql +Python3的方式。主机自带了python3和pip3。笔者自行安装了剩下的部分。其中，mysql的安装借鉴了这篇<a href="https://blog.csdn.net/qq_43232506/article/details/102816659">参考博文</a>。如有疑问欢迎大家在评区留言。<br>附言:以下操作，笔者都是以root身份进行的，读者以其他用户进行时，请酌情在命令前加上sudo。</p></blockquote><h2 id="1-Nginx"><a href="#1-Nginx" class="headerlink" title="1.Nginx"></a>1.Nginx</h2><h5 id="1-1阿里云放通80端口"><a href="#1-1阿里云放通80端口" class="headerlink" title="1.1阿里云放通80端口"></a>1.1阿里云放通80端口</h5><p>在阿里云的控制台中，对实例主机配置安全组，在入方向新增80端口的安全规则。配置如有疑问请参考<a href="https://help.aliyun.com/document_detail/25475.html?spm=5176.2020520101.121.1.57bb4df5DMKEqy">官方说明</a>。</p><h5 id="1-2安装nginx"><a href="#1-2安装nginx" class="headerlink" title="1.2安装nginx"></a>1.2安装nginx</h5><p>由于笔者对nginx的版本没有过多要求，此处采用dnf包管理方式安装，此处笔者dnf安装的是14.1版本。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dnf <span class="token function">install</span> <span class="token parameter variable">-y</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>安装完成后，可以查看一下版本，以验证是否正确安装。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="1-3nginx管理"><a href="#1-3nginx管理" class="headerlink" title="1.3nginx管理"></a>1.3nginx管理</h5><p>基于dnf安装的nginx已经做好了相关设置，可以使用nginx -s、systemctl对nginx进行便捷管理。<br>systemctl管理常用:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> nginx <span class="token comment">#开机自启动nginx</span>systemctl disable nginx <span class="token comment">#开机禁止启动nginx</span>systemctl status nginx <span class="token comment">#查看nginx服务状态</span>systemctl start nginx <span class="token comment">#开启nginx服务</span>systemctl stop nginx <span class="token comment">#终止nginx服务</span>systemctl restart nginx <span class="token comment">#重启nginx服务 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>相比之下，笔者还是更喜欢直接使用原生的nginx自带命令<br>通过nginx -h 读者可以查看到nginx常用命令及说明，笔者摘录了一部分</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx <span class="token parameter variable">-V</span> <span class="token comment">#查看nginx版本和配置项内容</span>nginx <span class="token parameter variable">-t</span>  <span class="token comment">#检查配置文件是否正确</span>nginx <span class="token parameter variable">-c</span>  配置文件路径 <span class="token comment">#选用某一配置文件</span>nginx  <span class="token comment">#启动nginx</span>nginx <span class="token parameter variable">-s</span> reload  <span class="token comment">#重新载入配置文件</span>nginx <span class="token parameter variable">-s</span> stop <span class="token comment">#停止nginx</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h5 id="1-4nginx使用"><a href="#1-4nginx使用" class="headerlink" title="1.4nginx使用"></a>1.4nginx使用</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start nginx <span class="token comment">#或者直接使用nginx 启动nginx服务</span>systemctl status nginx <span class="token comment">#若看到Active变为active(running)则启动正常</span><span class="token function">lsof</span> <span class="token parameter variable">-i:80</span><span class="token comment">#可以看到80端口已经被nginx监听了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>上面一系列检查确认nginx正常启动后，可以到浏览器输入公网地址或域名，看到nginx欢迎页。<br>nginx默认配置中监听80端口的配置项所在根位置，对应nginx程序安装目录下的html目录。我们通过<code>nginx -V</code>可以看到，dnf安装后，nginx安装位置在&#x2F;usr&#x2F;share&#x2F;nginx,配置文件在&#x2F;etc&#x2F;nginx&#x2F;nginx.conf。(欢迎页就是&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html)。<br>笔者还是更习惯将网站目录设置在&#x2F;var&#x2F;www下，我们可以这样来修改:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /var/www/mysite  <span class="token comment">#创建网站目录</span><span class="token function">cp</span> /usr/share/nginx/html/* /var/www/mysite/   <span class="token comment">#笔者暂时没网站,先用默认</span><span class="token function">cp</span> /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak <span class="token comment">#备份配置文件</span><span class="token function">vim</span> /etc/nginx/nginx.conf<span class="token comment">#打开配置文件 按i编辑</span><span class="token comment">##找到其中http->listen80的server项->修改root为/var/www/mysite;</span><span class="token comment">##按ESC后输入:wq 保存退出</span>nginx <span class="token parameter variable">-t</span><span class="token comment">#测试配置文件是否修改正确</span>nginx <span class="token parameter variable">-s</span> relod <span class="token comment">#无误后重新载入配置文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>大功告成，网站目录修改成功。(准确说是80端口web内容映射的根目录位置)</p><h2 id="2-Mysql"><a href="#2-Mysql" class="headerlink" title="2.Mysql"></a>2.Mysql</h2><h5 id="2-1安装mysql8-0"><a href="#2-1安装mysql8-0" class="headerlink" title="2.1安装mysql8.0"></a>2.1安装mysql8.0</h5><p>Centos8的dnf对懒人那是相当友好。mysql8.0的完全可以一条命令解决:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dnf <span class="token function">install</span> <span class="token parameter variable">-y</span> @mysql  <span class="token comment">#@mysql模块将安装MySQL8.0及其所有依赖项</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="2-2启动mysql"><a href="#2-2启动mysql" class="headerlink" title="2.2启动mysql"></a>2.2启动mysql</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> mysqld   <span class="token comment">#配置mysql开机自启动</span>systemctl start mysqld       <span class="token comment">#启动mysqld</span>systemctl status mysqld   <span class="token comment">#查看mysql是否启动成功(active running)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h5 id="2-3安全设置"><a href="#2-3安全设置" class="headerlink" title="2.3安全设置"></a>2.3安全设置</h5><p>运行如下脚本，可以设置mysql的root密码，并引导你完成一些必要的安全设置。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql_secure_installation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>首先，脚本会让你选择是否配置VALIDATE PASSWORD PLUGIN(密码验证插件)，该插件用来检查mysql用户所设置的密码强度，只有达到一定强度的密码才允许被设置。如果你希望设置请输入y或者Y回车，不想请直接回车。若选择了配置，紧接着你将选择所采用密码验证策略的级别：</p><blockquote><p>低:密码长度不少于8位<br>中:密码长度不少于8位，必须是数字、大小写字母、特殊字母混合。<br>强:密码长度不少于8位，必须是数字、大小写字母、特殊字母混合，需配合字典文件。</p></blockquote><p>通常，我们选择中级别即可。</p><p>其次，将要求用户输入两次为root设置的新密码，上一步骤设置的密码验证策略将发挥作用，并对用户设置的密码强度进行打分。设置好密码以后，会提示用户是否继续采用密码保护，选择y回车。</p><p>紧接着，将询问用户是否删除匿名用户，选择y回车。</p><blockquote><p>默认情况下，MySQL有一个匿名用户，允许任何人登录MySQL，而不必创建用户帐户。这仅用于测试，或者安装时更便利。但在部署生产环境之前，应该先删除匿名用户。</p></blockquote><p>然后，将询问用户是否禁止以root身份远程登陆mysql，选择y回车。</p><blockquote><p>通常，mysql中的root用户应只允许通过本地登陆，而不能远程登陆。这样可以降低root用户密码被爆破的风险。</p></blockquote><p>此后，将询问用户是否删除测试数据库，选择y回车。</p><blockquote><p>默认情况下，MySQL总有一个名为’test’的数据库，允许任何用户访问。这仅用于安装时的测试，但在部署生产环境之前，应该先删除该数据库。</p></blockquote><p>最后，脚本询问用户是否现在重载 privilege tables，以使当前所有修改立刻生效。选择y回车。</p><p>当我们在终端中键入:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span> <span class="token comment">#回车输入密码并确认</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>即可登陆mysql。</p><h2 id="3-Django"><a href="#3-Django" class="headerlink" title="3.Django"></a>3.Django</h2><p>Django作为python得力的重量级web框架，一直备受青睐。</p><h5 id="3-1安装django"><a href="#3-1安装django" class="headerlink" title="3.1安装django"></a>3.1安装django</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip3 <span class="token function">install</span> django<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="3-2关联mysql"><a href="#3-2关联mysql" class="headerlink" title="3.2关联mysql"></a>3.2关联mysql</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dnf <span class="token function">install</span> mysql-develpip3 <span class="token function">install</span> mysqlclient<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h5 id="3-3Django项目"><a href="#3-3Django项目" class="headerlink" title="3.3Django项目"></a>3.3Django项目</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">django-admin startproject  myproject   <span class="token comment">#创建一个名为myproject的项目</span><span class="token builtin class-name">cd</span> myprojectpython3 manage.py startapp dg_mypr  <span class="token comment">#创建一个应用dg_mypr用来映射数据库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>上述创建的应用，通过在models.py中利用Django的ORM映射数据库的表和字段，一般为了统一我们会使该应用与数据库同名。</p><p>打开项目下的配置文件settings.py</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">DATABASES <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'default'</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">'ENGINE'</span><span class="token punctuation">:</span> <span class="token string">'django.db.backends.sqlite3'</span><span class="token punctuation">,</span>        <span class="token string">'NAME'</span><span class="token punctuation">:</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>BASE_DIR<span class="token punctuation">,</span> <span class="token string">'db.sqlite3'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">#上述内容修改为mysql引擎，填入要连接的数据库信息</span><span class="token comment">#要注意的是 这里的数据库必须是提前创建好的！！！！！</span>DATABASES <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'default'</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">'ENGINE'</span><span class="token punctuation">:</span> <span class="token string">'django.db.backends.mysql'</span><span class="token punctuation">,</span>        <span class="token string">'NAME'</span><span class="token punctuation">:</span> <span class="token string">'数据库名'</span><span class="token punctuation">,</span>        <span class="token string">'USER'</span><span class="token punctuation">:</span> <span class="token string">'root'</span><span class="token punctuation">,</span>        <span class="token string">'PASSWORD'</span><span class="token punctuation">:</span> <span class="token string">'密码'</span><span class="token punctuation">,</span>        <span class="token string">'HOST'</span><span class="token punctuation">:</span> <span class="token string">'localhost'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#在这里插入新创建的app</span>INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'django.contrib.admin'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.contenttypes'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.sessions'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.messages'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.staticfiles'</span><span class="token punctuation">,</span>    <span class="token string">'dg_mypr'</span><span class="token punctuation">,</span><span class="token comment">#加入dg_mypr</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">DEBUG <span class="token operator">=</span> <span class="token boolean">True</span><span class="token comment">#测试中打开Debug 生产环境请关闭</span>ALLOWED_HOSTS <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">u'*'</span><span class="token punctuation">]</span><span class="token comment">#修改白名单为全通</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>修改完成后，保存退出。<br>(在dg_mypr中的models.py中定义ORM映射模型的步骤略)<br>改好配置文件并创建模型后，我们可以使用</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 manage.py check   <span class="token comment">#确认正常连接数据库且语法正确(0 issues)</span>python3 manage.py makemigrations  <span class="token comment">#根据模型建立migration</span>python3 manage.py migrate  <span class="token comment">#根据migration在数据库中建立对应的表</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>此后若需要应用新的ORM建模，可以在清库后，删除dg_mypr&#x2F;migrations目录下的__pycache__和0001_initial.py，重复上述两步操作即可。<br>最后，我们可以在开着debug的情况下应用runserver跑一个端口测试一下:<br>(确保阿里云安全策略组已开放该端口)</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 manage.py runserver <span class="token number">0.0</span>.0.0:8080  <span class="token comment">#监听8080端口建立项目服务</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>当浏览器访问http:&#x2F;&#x2F;公网地址:端口 后，若载入了Django欢迎页，则进入下一步骤。</p><h2 id="4-uWSGI"><a href="#4-uWSGI" class="headerlink" title="4.uWSGI"></a>4.uWSGI</h2><h5 id="4-1安装uwsgi"><a href="#4-1安装uwsgi" class="headerlink" title="4.1安装uwsgi"></a>4.1安装uwsgi</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 <span class="token parameter variable">-m</span> pip <span class="token function">install</span> uwsgi<span class="token comment">#安装完成后测试一下</span>uwsgi <span class="token parameter variable">--version</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h5 id="4-2写项目配置文件"><a href="#4-2写项目配置文件" class="headerlink" title="4.2写项目配置文件"></a>4.2写项目配置文件</h5><p>在项目的目录 &#x2F;var&#x2F;www&#x2F;mysite&#x2F;myproject 下创建一个ini配置文件<br>并创建一个目录uwsgi用来存放运行相关文件 </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> myproject.ini<span class="token function">mkdir</span> uwsgi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>在myproject.ini中写入:</p><figure><div class="code-wrapper"><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"><span class="token comment"># myproject.ini </span><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">uwsgi</span><span class="token punctuation">]</span></span><span class="token comment">#内部转发端口 只要不被占用可随意找 需和nginx.conf里的转发口匹配</span><span class="token key attr-name">socket</span> <span class="token punctuation">=</span> <span class="token value attr-value">:8888</span><span class="token comment">#django 项目目录</span><span class="token key attr-name">chdir</span>           <span class="token punctuation">=</span> <span class="token value attr-value">/var/www/mysite/myproject</span><span class="token comment">#Django 项目下 wsgi.py 文件</span><span class="token key attr-name">module</span>          <span class="token punctuation">=</span> <span class="token value attr-value">myproject.wsgi</span><span class="token key attr-name">master</span>          <span class="token punctuation">=</span> <span class="token value attr-value">true</span><span class="token comment">#进程数</span><span class="token key attr-name">processes</span>       <span class="token punctuation">=</span> <span class="token value attr-value">4</span><span class="token key attr-name">vacuum</span>          <span class="token punctuation">=</span> <span class="token value attr-value">true</span><span class="token comment">#status文件，可以查看uwsgi的运行状态</span><span class="token key attr-name">stats</span>           <span class="token punctuation">=</span><span class="token value attr-value">%(chdir)/uwsgi/uwsgi.status</span><span class="token comment">#pid文件，通过该文件可以控制uwsgi的重启和停止</span><span class="token key attr-name">pidfile</span>         <span class="token punctuation">=</span><span class="token value attr-value">%(chdir)/uwsgi/uwsgi.pid</span><span class="token comment">#日志文件，通过该文件查看uwsgi的日志</span><span class="token key attr-name">daemonize</span>       <span class="token punctuation">=</span><span class="token value attr-value">%(chdir)/uwsgi/uwsgi.log</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h5 id="4-3写nginx配置文件"><a href="#4-3写nginx配置文件" class="headerlink" title="4.3写nginx配置文件"></a>4.3写nginx配置文件</h5><p>在nginx配置文件nginx.conf中加入</p><figure><div class="code-wrapper"><pre class="line-numbers language-hoon" data-language="hoon"><code class="language-hoon"><span class="token function">server</span> &#123;    <span class="token function">listen</span> 8080; #暴露给外部访问的端口 根据实际指定 确认阿里云策略组已放行    <span class="token function">server</span>_<span class="token function">name</span> <span class="token function">localhost</span>;      <span class="token function">charset</span> <span class="token function">utf-8</span>;    <span class="token function">location</span> / &#123;   <span class="token function">include</span> <span class="token function">uwsgi</span>_<span class="token function">params</span>;    <span class="token function">uwsgi</span>_<span class="token function">pass</span> 127.0.0.1:8888; #外部访问端口就转发到内部端口 要与项目配置文件里的一致    &#125;    <span class="token function">location</span> /<span class="token function">static</span>/ &#123;        <span class="token function">alias</span> /<span class="token function">var</span>/<span class="token function">www</span>/<span class="token function">mysite</span>/<span class="token function">myproject</span>/<span class="token function">static</span>/; #项目静态路径设置    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>写完后运行 <code>nginx -t</code>检测一下是否有语法错误<br>然后运行<code>nginx -s reload</code>重新载入配置文件</p><h5 id="4-4运行"><a href="#4-4运行" class="headerlink" title="4.4运行"></a>4.4运行</h5><p>回到项目目录 运行 <code>uwsgi --ini myproject.ini</code>即可<br>可运行<code>cat uwsgi/uwsgi.log</code>查看一下是否正常启动了uwsgi<br>当看到如下内容 说明正常启动了</p><figure><div class="code-wrapper"><pre class="line-numbers language-shell-session" data-language="shell-session"><code class="language-shell-session"><span class="token output">*** uWSGI is running in multiple interpreter mode ***spawned uWSGI master process (pid: 1405)spawned uWSGI worker 1 (pid: 1413, cores: 1)spawned uWSGI worker 2 (pid: 1414, cores: 1)spawned uWSGI worker 3 (pid: 1415, cores: 1)spawned uWSGI worker 4 (pid: 1416, cores: 1)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>此时，运行<code>ps aux | grep uwsgi</code>可查看到正在运行的uwsgi实例</p><h5 id="4-5管理"><a href="#4-5管理" class="headerlink" title="4.5管理"></a>4.5管理</h5><p>倘若不撰写管理脚本 需要重启uwsgi时总是需要</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> <span class="token parameter variable">-ax</span> <span class="token operator">|</span> <span class="token function">grep</span> uwsgi$ <span class="token function">kill</span> <span class="token parameter variable">-9</span> <span class="token punctuation">[</span>pid<span class="token punctuation">]</span>$ uwsgi <span class="token parameter variable">--ini</span> myproject.ini<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>但是如果你按照第二步创建了uwsgi目录及相关文件，你就可以优雅地管理uwsgi进程。</p><h6 id="4-5-1安装uwsgitop"><a href="#4-5-1安装uwsgitop" class="headerlink" title="4.5.1安装uwsgitop"></a>4.5.1安装uwsgitop</h6><p>uwsgitop是一款界面类似top的工具，用以查看指定uwsgi的全部工作进程情况。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip3 <span class="token function">install</span> uwsgitop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h6 id="4-5-2管理相关命令"><a href="#4-5-2管理相关命令" class="headerlink" title="4.5.2管理相关命令"></a>4.5.2管理相关命令</h6><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#重启uwsgi(常常出错 还是执行stop以后start效率高)</span>uwsgi <span class="token parameter variable">--reload</span> uwsgi/uwsgi.pid<span class="token comment">#终止uwsgi(原理是启动uwsgi进程时会把pid写入该文件)</span>uwsgi <span class="token parameter variable">--stop</span> uwsgi/uwsgi.pid<span class="token comment">#查看uwsgi各进程工作状况</span>uwsgitop uwsgi/uwsgi.status<span class="token comment">#追踪uwsgi日志及动态刷新当前访问记录</span><span class="token function">tail</span> <span class="token parameter variable">-f</span> uwsgi/uwsgi.log<span class="token comment">#启动uwsgi</span>uwsgi <span class="token parameter variable">--ini</span> myproject.ini<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如果不便记忆，可将上述命令写入sh脚本文件 快捷执行。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> uwsgi<span class="token builtin class-name">echo</span> <span class="token string">"uwsgi --ini ../myproject.ini"</span> <span class="token operator">></span>start.sh<span class="token builtin class-name">echo</span> <span class="token string">"uwsgi --stop uwsgi.pid"</span> <span class="token operator">></span>stop.sh<span class="token builtin class-name">echo</span> <span class="token string">"uwsgitop uwsgi.status"</span> <span class="token operator">></span>status.sh<span class="token builtin class-name">echo</span> <span class="token string">"tail -f uwsgi.log"</span><span class="token operator">></span>log.sh<span class="token function">chmod</span> +x *.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可在浏览器访问项目地址,测试效果。</p><p>综上，笔者整理了自己部署环境的全过程，希望能够对读者有所帮助。后续如有其他内容，将继续补丁修正。欢迎评论指正！</p>]]></content>
    
    
    <categories>
      
      <category>经验整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>CentOS8</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS8使用yum与dnf出现缓存同步错误</title>
    <link href="/posts/30e05259/"/>
    <url>/posts/30e05259/</url>
    
    <content type="html"><![CDATA[<p>在新装的Centos8上使用yum和dnf时发生报错，来此记录一下。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ yum <span class="token function">install</span> xxx$ Error: Failed to synchronize cache <span class="token keyword">for</span> repo <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ dnf <span class="token function">install</span> xxx$ Error: Failed to synchronize cache <span class="token keyword">for</span> repo <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /etc/yum.repos.d<span class="token comment">#之后 查找并删除出现问题的 repo仓库</span><span class="token comment">#若未找到 则打开 CentOS-Base.repo找</span>$ yum clean all$ yum makecache<span class="token comment">#dnf也像上边一样即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="出现问题的原因"><a href="#出现问题的原因" class="headerlink" title="出现问题的原因"></a>出现问题的原因</h2><ol><li>该源已经失效</li><li>该源当前网络不可达（俗称 qiang掉）</li><li>该源同当前系统版本不符合</li></ol>]]></content>
    
    
    <categories>
      
      <category>问题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Centos8</tag>
      
      <tag>dnf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django2.x实现跨域请求</title>
    <link href="/posts/3fb71c64/"/>
    <url>/posts/3fb71c64/</url>
    
    <content type="html"><![CDATA[<h2 id="1-使用pip安装django的Cros模块"><a href="#1-使用pip安装django的Cros模块" class="headerlink" title="1.使用pip安装django的Cros模块"></a>1.使用pip安装django的Cros模块</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip3 <span class="token function">install</span> django-cors-headers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="2-修改Django项目的Settings-py"><a href="#2-修改Django项目的Settings-py" class="headerlink" title="2.修改Django项目的Settings.py"></a>2.修改Django项目的Settings.py</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#注册app</span>INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token string">'corsheaders'</span>，<span class="token comment">#增加</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span> <span class="token comment"># 添加中间件</span>MIDDLEWARE <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token string">'corsheaders.middleware.CorsMiddleware'</span><span class="token punctuation">,</span><span class="token comment"># 新增</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span><span class="token comment">##跨域的配置</span><span class="token comment">#尤其注意允许访问的域名白名单 和开启CORS_ORIGIN_ALLOW_ALL 二选一 不要全设置</span><span class="token comment">#CORS_ORIGIN_WHITELIST 中的域名请携带协议名称</span>CORS_ORIGIN_WHITELIST <span class="token operator">=</span> <span class="token punctuation">(</span>                <span class="token string">'*'</span><span class="token punctuation">)</span>CORS_ORIGIN_ALLOW_ALL <span class="token operator">=</span> <span class="token boolean">True</span><span class="token comment">#允许跨域请求的请求方法类型</span>CORS_ALLOW_METHODS <span class="token operator">=</span> <span class="token punctuation">(</span>    <span class="token string">'DELETE'</span><span class="token punctuation">,</span>    <span class="token string">'GET'</span><span class="token punctuation">,</span>    <span class="token string">'OPTIONS'</span><span class="token punctuation">,</span>    <span class="token string">'PATCH'</span><span class="token punctuation">,</span>    <span class="token string">'POST'</span><span class="token punctuation">,</span>    <span class="token string">'PUT'</span><span class="token punctuation">,</span>    <span class="token string">'VIEW'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token comment">#允许跨域请求的请求头类型</span>CORS_ALLOW_HEADERS <span class="token operator">=</span> <span class="token punctuation">(</span>    <span class="token string">'XMLHttpRequest'</span><span class="token punctuation">,</span>    <span class="token string">'X_FILENAME'</span><span class="token punctuation">,</span>    <span class="token string">'accept-encoding'</span><span class="token punctuation">,</span>    <span class="token string">'authorization'</span><span class="token punctuation">,</span>    <span class="token string">'content-type'</span><span class="token punctuation">,</span>    <span class="token string">'dnt'</span><span class="token punctuation">,</span>    <span class="token string">'origin'</span><span class="token punctuation">,</span>    <span class="token string">'user-agent'</span><span class="token punctuation">,</span>    <span class="token string">'x-csrftoken'</span><span class="token punctuation">,</span>    <span class="token string">'x-requested-with'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token comment">#开启后允许cookie传递 必备</span>CORS_ALLOW_CREDENTIALS <span class="token operator">=</span> <span class="token boolean">True</span><span class="token comment">#云服务器部署时候请务必打开</span>ALLOWED_HOSTS <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">u'*'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="3-检测配置"><a href="#3-检测配置" class="headerlink" title="3.检测配置"></a>3.检测配置</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 manage.py check   <span class="token comment">#无报错即配置正常</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>经验整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>跨域</tag>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序调试遇到SSL握手错误</title>
    <link href="/posts/f32a927e/"/>
    <url>/posts/f32a927e/</url>
    
    <content type="html"><![CDATA[<h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><p>在服务器上重新部署ssl证书以后，浏览器访问、小程序PC端调试均无问题。但在移动端测试以及线上demo均出现了”ssl hand shake error”错误。疑似证书不被认可。</p><h4 id="解决思路："><a href="#解决思路：" class="headerlink" title="解决思路："></a>解决思路：</h4><p>1.前往该网站检测服务器证书的安装情况 <a href="https://www.myssl.cn/tools/check-server-cert.html">https://www.myssl.cn/tools/check-server-cert.html</a><br>2.查看根证书、中间件是否正常。发现检测报告提示<strong>找不到中间件</strong><br>3.前往该网站生成中间件<a href="https://www.myssl.cn/tools/downloadchain.html">https://www.myssl.cn/tools/downloadchain.html</a><br>4.进入网站后输入证书文件内容，点击下一步，即可跳转到中间件下载页面，下载后上传至服务器。<br>5.笔者的服务器部署apache, 故而在&#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;ssl.conf中加入</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SSLCertificateChainFile  ssl/server.chain  <span class="token comment">#证书存放位置为/etc/httpd/ssl/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>6.保存配置文件后，运行apachectl configtest 确认配置无误后，重启apache</p><p>内容参考:<a href="https://www.jianshu.com/p/9f825044a0df">https://www.jianshu.com/p/9f825044a0df</a></p>]]></content>
    
    
    <categories>
      
      <category>问题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
      <tag>ssl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用git拉取时出现SSL_connect错误</title>
    <link href="/posts/b832a5c0/"/>
    <url>/posts/b832a5c0/</url>
    
    <content type="html"><![CDATA[<p>﻿#### 问题描述</p><p>之前顺利克隆下的仓库，某天在执行pull时候出现如下错误:<br><strong>fatal: unable to access ‘<a href="https://gitee.com/xiaoming/xiaoming.git/">https://gitee.com/xiaoming/xiaoming.git/</a>‘: OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to gitee.com:443</strong></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在Linux的bash中 或者在Win下的GitBash中，键入如下即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">env</span> <span class="token assign-left variable">GIT_SSL_NO_VERIFY</span><span class="token operator">=</span>true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>问题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git记住账号密码</title>
    <link href="/posts/dcbfefd3/"/>
    <url>/posts/dcbfefd3/</url>
    
    <content type="html"><![CDATA[<h4 id="1-永久记住密码"><a href="#1-永久记住密码" class="headerlink" title="1.永久记住密码"></a>1.永久记住密码</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> credential.helper store<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>会在用户主目录的.gitconfig文件中加入下面的配置。如果没有–global，则加在当前项目下的.git&#x2F;config文件中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">[</span>credential<span class="token punctuation">]</span>helper <span class="token operator">=</span> store<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h4 id="2-临时记住密码"><a href="#2-临时记住密码" class="headerlink" title="2.临时记住密码"></a>2.临时记住密码</h4><p>采用默认的方式会记住密码15分钟</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> credential.helper cache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>也可以自己指定时长（timeout单位为秒）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> credential.helper <span class="token string">'cache -timeout=60'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="3-录入账密"><a href="#3-录入账密" class="headerlink" title="3.录入账密"></a>3.录入账密</h4><p>执行完上述任意一步骤后 还需执行如下步骤才能记录账号密码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> pull<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>….如遇到其他情况再行补充</p>]]></content>
    
    
    <categories>
      
      <category>经验整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于DosBox的汇编环境部署</title>
    <link href="/posts/455c8476/"/>
    <url>/posts/455c8476/</url>
    
    <content type="html"><![CDATA[<blockquote><p>包含DosBox安装包和一组MASM+LINK+EDIT+DEBUG配套工具的包可在此处<a href="http://download.csdn.net/download/l1175832366/12209322">下载</a>。<br>软件配置环境:Win10  Win7_64  Win7_32   (笔者以下内容 基于Win10主流机,Win7同理)</p></blockquote><h3 id="1-创建工程目录"><a href="#1-创建工程目录" class="headerlink" title="1.创建工程目录"></a>1.创建工程目录</h3><p>在电脑上创建一个文件夹用来充当我们存放工具、代码的工程目录。<br>笔者创建的是(E:\lb)，我们将MASM文件夹放在该目录下，如图:<br><img src="https://img-blog.csdnimg.cn/20200303173948207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMTc1ODMyMzY2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-安装DOSBox"><a href="#2-安装DOSBox" class="headerlink" title="2.安装DOSBox"></a>2.安装DOSBox</h3><p>双击压缩包中的DOSBox0.74-win32-installer.exe 以安装<strong>DOSBox</strong>(这是一款自带DOS的X86仿真器)安装过程中选择好安装目录然后一路Next即可，安装成功后桌面上会出现DosBox的快捷方式。<br><img src="https://img-blog.csdnimg.cn/2020030317401645.png" alt="在这里插入图片描述"></p><h3 id="3-自动挂载工作空间"><a href="#3-自动挂载工作空间" class="headerlink" title="3.自动挂载工作空间"></a>3.自动挂载工作空间</h3><p>双击打开快捷方式以后会出现两个窗口(脚本控制窗与软件窗)，如下图红圈中内容，是本机当前用户DosBox的配置文件的路径。</p><p><img src="https://img-blog.csdnimg.cn/20200303174028860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMTc1ODMyMzY2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 选中该路径后，Ctrl+C复制到资源管理器中，回车(<strong>选择记事本</strong>)打开配置文件。拉至最底部，在“autoexec”配置字段下加入如下图三条命令并保存退出。  </p><p><img src="https://img-blog.csdnimg.cn/2020030317403856.png" alt="在这里插入图片描述"></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#[autoexec]字段下加入的命令会在DOSBox开启后自动执行，免去了每次开启都进行挂载#MOUNT C: E:\lb  #是将刚才创建的工作目录挂载到C盘(此处的C盘为虚拟盘符可自由指定) C:                #是切换到C盘盘符PATH&#x3D;C:\MASM;%PATH%#将汇编工具目录加入环境变量PATH中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="4-检查效果"><a href="#4-检查效果" class="headerlink" title="4.检查效果"></a>4.检查效果</h3><p>关闭DOSBox并重新打开，可以看到刚才配置的命令已经自动执行了。<br><img src="https://img-blog.csdnimg.cn/20200303174059448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMTc1ODMyMzY2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>此时运行masm，出现如下内容，表示环境部署完成。</p><p><img src="https://img-blog.csdnimg.cn/20200303174110648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMTc1ODMyMzY2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="5-补充"><a href="#5-补充" class="headerlink" title="5.补充"></a>5.补充</h3><p>(注：我们的之后的所有操作虽然都在软件窗口中进行，但脚本窗是不能关闭的，当它是个背景就好)</p><h5 id="5-1关于支持命令与快捷键"><a href="#5-1关于支持命令与快捷键" class="headerlink" title="5.1关于支持命令与快捷键"></a>5.1关于支持命令与快捷键</h5><p>DOSBox并非DOS，只集成了DOS中非常有限的命令中非常有限的功能，读者可根据自身需求去下载相应的exe工具并放置在配置了环境变量的目录中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">help all查看DOSBox自身集成的命令工具exit退出程序Alt+Enter 全屏&#x2F;窗口 切换 （常用）Ctrl+F7         降低跳桢数Ctrl+F8 提高跳桢数Ctrl+F9 强制退出DOSBOXCtrl+F10  显示&#x2F;隐藏 系统鼠标Ctrl+F11  降低“DOS模拟CPU”速度（常用）Ctrl+F12 提高“DOS模拟CPU”速度（常用）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h5 id="5-2关于全屏闪退问题"><a href="#5-2关于全屏闪退问题" class="headerlink" title="5.2关于全屏闪退问题"></a>5.2关于全屏闪退问题</h5><p>部分Win10用户在使用DOSBox时，存在全屏闪退问题，笔者遇到的情况是通过以下方式解决的:</p><p>用记事本打开DOSBox配置文件(方法见第三步)</p><p>Ctrl+F 查找到” output “ 字段，如下图:</p><p><img src="https://img-blog.csdnimg.cn/20200303174129736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2wxMTc1ODMyMzY2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>可以看到默认值是”surface” ，现在我们需要将该值改为” opengl “，如下图:</p><p><img src="https://img-blog.csdnimg.cn/20200303174155303.png" alt="在这里插入图片描述"><br>保存退出，重启DOSBox，大功告成。<br>（如果该方法不成功，还可以在oengl模式下，修改配置文件中windowresolution&#x3D;1920x1080  比例可以自己定，用来设定窗口的初始大小）</p>]]></content>
    
    
    <categories>
      
      <category>经验整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
      <tag>DosBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7后端开发环境(LAMP)部署</title>
    <link href="/posts/3b61517d/"/>
    <url>/posts/3b61517d/</url>
    
    <content type="html"><![CDATA[<p>以下博文记录为2018年 部分内容或老旧 仅供参考<br>接下来是笔者根据自己经历整理的从零开始在CentOs7.3上搭建环境（实测在腾讯云  阿里云主机上无误）<br>我们所采用的是如下配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Apache2.4 + MySQL5.7+PHP7.1+phpMyAdmin4.8+python3.6(pip3) +MOD_WSGI4.5+Django2.x<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><h5 id="1-安装apache2-4及其扩增包"><a href="#1-安装apache2-4及其扩增包" class="headerlink" title="1.安装apache2.4及其扩增包"></a>1.安装apache2.4及其扩增包</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> httpd httpd-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="2-配置servername"><a href="#2-配置servername" class="headerlink" title="2.配置servername"></a>2.配置servername</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span> /etc/httpd/conf/httpd.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>修改ServerName如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-apacheconf" data-language="apacheconf"><code class="language-apacheconf"><span class="token directive-inline property">ServerName</span> localhost:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="3-启动apache-并设置开机启动"><a href="#3-启动apache-并设置开机启动" class="headerlink" title="3.启动apache 并设置开机启动"></a>3.启动apache 并设置开机启动</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start httpd<span class="token function">chkconfig</span> httpd on<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h5 id="4-访问主机地址"><a href="#4-访问主机地址" class="headerlink" title="4.访问主机地址"></a>4.访问主机地址</h5><p>看一下是否运行正确（出现Test123..欢迎页面说明正确了）</p><h5 id="5-防目录泄露"><a href="#5-防目录泄露" class="headerlink" title="5.防目录泄露"></a>5.防目录泄露</h5><p>我们通常不希望自己的网站目录轻易被访问者看到或被有心人爆出。而apache默认配置中，只要没有index，就会显示网站目录，这一点我们要做一定修改<br>需要将以下内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-apacheconf" data-language="apacheconf"><code class="language-apacheconf"><span class="token directive-block tag"><span class="token directive-block tag"><span class="token punctuation">&lt;</span>Directory</span><span class="token directive-block-parameter attr-value"> /var/www/</span><span class="token punctuation">></span></span><span class="token directive-inline property">Options</span> Indexes FollowSymLinks<span class="token directive-inline property">AllowOverride</span> None<span class="token directive-inline property">Require</span> all granted<span class="token directive-block tag"><span class="token directive-block tag"><span class="token punctuation">&lt;/</span>Directory</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>修改为</strong>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-apacheconf" data-language="apacheconf"><code class="language-apacheconf"><span class="token directive-block tag"><span class="token directive-block tag"><span class="token punctuation">&lt;</span>Directory</span><span class="token directive-block-parameter attr-value"> /var/www/</span><span class="token punctuation">></span></span><span class="token directive-inline property">Options</span> FollowSymLinks<span class="token directive-inline property">AllowOverride</span> None<span class="token directive-inline property">Require</span> all granted<span class="token directive-block tag"><span class="token directive-block tag"><span class="token punctuation">&lt;/</span>Directory</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h2><h5 id="1-安装MySQL源"><a href="#1-安装MySQL源" class="headerlink" title="1.安装MySQL源"></a>1.安装MySQL源</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum localinstall http://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="2-安装MySQL"><a href="#2-安装MySQL" class="headerlink" title="2.安装MySQL"></a>2.安装MySQL</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> mysql-community-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="3-启动MySQL"><a href="#3-启动MySQL" class="headerlink" title="3.启动MySQL"></a>3.启动MySQL</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="4-获取密码"><a href="#4-获取密码" class="headerlink" title="4.获取密码"></a>4.获取密码</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token string">'temporary password'</span> /var/log/mysqld.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>你会得到这行 A temporary password is generated for root@localhost: Jqqskhz1Wr(?<br>冒号后面的就是密码</p><h5 id="5-进入MySQL"><a href="#5-进入MySQL" class="headerlink" title="5.进入MySQL"></a>5.进入MySQL</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>输入你刚才获得的密码，你会进入mysql&gt;。</p><h5 id="6-修改密码"><a href="#6-修改密码" class="headerlink" title="6.修改密码"></a>6.修改密码</h5><p>星号为你输入的密码，不要丢了引号，密码建议大小写加数字加特殊字符，太简单的密码会被拒绝</p><figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">USER</span> <span class="token string">'root'</span><span class="token variable">@'localhost'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'*************'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="7-开放远程访问权限"><a href="#7-开放远程访问权限" class="headerlink" title="7.开放远程访问权限"></a>7.开放远程访问权限</h5><figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> mysql<span class="token punctuation">;</span><span class="token keyword">update</span> <span class="token keyword">user</span> <span class="token keyword">set</span> host <span class="token operator">=</span> <span class="token string">'%'</span> <span class="token keyword">where</span> <span class="token keyword">user</span> <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>百分号相当于*号，意为全部放行，也可改为IP地址则只允许此IP连接，也可以设置为192.168.%.%或者192.168.0.1&#x2F;9代表允许一个ip段进行连接，也可以多加几条数据设置不同ip允许连接。</p><h2 id="PHP及关联配置"><a href="#PHP及关联配置" class="headerlink" title="PHP及关联配置"></a>PHP及关联配置</h2><h5 id="1-进入-x2F-usr-x2F-local文件夹"><a href="#1-进入-x2F-usr-x2F-local文件夹" class="headerlink" title="1.进入 &#x2F;usr&#x2F;local文件夹"></a>1.进入 &#x2F;usr&#x2F;local文件夹</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="2-下载php7-1-2"><a href="#2-下载php7-1-2" class="headerlink" title="2.下载php7.1.2"></a>2.下载php7.1.2</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> am1.php.net/get/php-7.1.20.tar.gz/from/this/mirror<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="3-解压下载的安装包"><a href="#3-解压下载的安装包" class="headerlink" title="3.解压下载的安装包"></a>3.解压下载的安装包</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> 包名<span class="token builtin class-name">cd</span> 解压后的目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h5 id="4-安装必要的依赖（很重要）"><a href="#4-安装必要的依赖（很重要）" class="headerlink" title="4.安装必要的依赖（很重要）"></a>4.安装必要的依赖（很重要）</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token parameter variable">-y</span> <span class="token function">install</span> libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel <span class="token function">curl</span> curl-devel openssl openssl-devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="5-安装gcc（如果你希望之后的编译源码顺利进行的话）"><a href="#5-安装gcc（如果你希望之后的编译源码顺利进行的话）" class="headerlink" title="5.安装gcc（如果你希望之后的编译源码顺利进行的话）"></a>5.安装gcc（如果你希望之后的编译源码顺利进行的话）</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> gcc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="6-安装必要扩展"><a href="#6-安装必要扩展" class="headerlink" title="6.安装必要扩展"></a>6.安装必要扩展</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token parameter variable">-y</span> <span class="token function">install</span> libxslt-devel*yum <span class="token parameter variable">-y</span> <span class="token function">install</span> perl*yum <span class="token parameter variable">-y</span> <span class="token function">install</span> httpd-devel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h5 id="7-安装状态测试"><a href="#7-安装状态测试" class="headerlink" title="7.安装状态测试"></a>7.安装状态测试</h5><p>如果 find &#x2F; -name apxs 得到的路径是:&#x2F;usr&#x2F;bin&#x2F;apxs 那么安装很顺利</p><h5 id="8-编译前的配置"><a href="#8-编译前的配置" class="headerlink" title="8.编译前的配置"></a>8.编译前的配置</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/local/php7 --with-curl --with-freetype-dir --with-gd --with-gettext --with-iconv-dir --with-kerberos --with-libdir<span class="token operator">=</span>lib64 --with-libxml-dir --with-mysqli --with-openssl --with-pcre-regex --with-pdo-mysql --with-pdo-sqlite --with-pear --with-png-dir --with-xmlrpc --with-xsl --with-zlib --enable-fpm --enable-bcmath -enable-inline-optimization --enable-gd-native-ttf --enable-mbregex --enable-mbstring --enable-opcache --enable-pcntl --enable-shmop --enable-soap --enable-sockets --enable-sysvsem --enable-xml --enable-zip --enable-pcntl --with-curl --with-fpm-user<span class="token operator">=</span>nginx --enable-ftp --enable-session --enable-xml --with-apxs2<span class="token operator">=</span>/usr/bin/apxs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="9-编译并安装"><a href="#9-编译并安装" class="headerlink" title="9.编译并安装"></a>9.编译并安装</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>编译出错请查看<a href="http://www.cnblogs.com/sweetXiaoma/p/5855732.html">http://www.cnblogs.com/sweetXiaoma/p/5855732.html</a></p><h5 id="10-添加环境变量"><a href="#10-添加环境变量" class="headerlink" title="10.添加环境变量"></a>10.添加环境变量</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>在末尾加入</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/usr/local/php7/bin<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>使改动生效</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>查看php版本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">php <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="11-生成必要文件"><a href="#11-生成必要文件" class="headerlink" title="11.生成必要文件"></a>11.生成必要文件</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> php.ini-production /usr/local/php7/etc/php.ini<span class="token function">cp</span> sapi/fpm/php-fpm /usr/local/php7/etc/php-fpm<span class="token function">cp</span> /usr/local/php7/etc/php-fpm.conf.default /usr/local/php7/etc/php-fpm.conf<span class="token function">cp</span> /usr/local/php7/etc/php-fpm.d/www.conf.default /usr/local/php7/etc/php-fpm.d/www.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h5 id="12-必要配置"><a href="#12-必要配置" class="headerlink" title="12.必要配置"></a>12.必要配置</h5><p>如果报错 请敲这行查报错信息 可以查到哪个文件第几行出错：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl status httpd.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>（1）修改Apache默认欢迎页：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/httpd/conf.d/welcome.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>将<code>/usr/share/httpd/noindex</code> 修改为<code>/var/www</code></p><p>（2）修改Apache配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/httpd/conf/httpd.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>将<strong>DocumentRoot</strong>的值修改为<code>/var/www/</code>，并将此文件中的另一处<code>/var/www/html</code>也改成<code>/var/www</code>，这样我们就可以直接在<code>/var/www</code>下放置我们想要在apache上跑的文件啦！</p><p>再在文件中找到如下内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-apacheconf" data-language="apacheconf"><code class="language-apacheconf"><span class="token directive-inline property">AddType</span> application/x-compress .Z<span class="token directive-inline property">AddType</span> application/x-gzip .gz .tgz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>在其后添加：</p><figure><div class="code-wrapper"><pre class="line-numbers language-apacheconf" data-language="apacheconf"><code class="language-apacheconf"><span class="token directive-inline property">AddType</span> application/x-httpd-php .php<span class="token directive-inline property">AddType</span> application/x-httpd-php-source .php7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>（4）搜索 <code>IfModule dir_module</code>并在下面添加<code>index.php </code>（如下）</p><figure><div class="code-wrapper"><pre class="line-numbers language-apacheconf" data-language="apacheconf"><code class="language-apacheconf">&lt; IfModule dir_module><span class="token directive-inline property">DirectoryIndex</span> index.html index.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>（5）搜索下面这一行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-apacheconf" data-language="apacheconf"><code class="language-apacheconf"><span class="token directive-inline property">LoadModule</span> php7_module modules/libphp7.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>如果没有请手动添加，缺失本行内容会出现无法运行php文件，php文件访问即下载。<br>（6）测试<br>在<code>\var\www</code>目录下创建打印php_info的主页。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"&lt;?php phpinfo();?>"</span><span class="token operator">>></span>index.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>浏览器里输入 <code>主机地址/index.php</code><br>出现php7.1的配置信息说明一切就绪。</p><h2 id="安装phpMyadmin"><a href="#安装phpMyadmin" class="headerlink" title="安装phpMyadmin"></a>安装phpMyadmin</h2><h5 id="1-下载软件包"><a href="#1-下载软件包" class="headerlink" title="1.下载软件包"></a>1.下载软件包</h5><p>下载最新版的phpmyadmin （如选用其他版本，可前往phpmyadmin官网查看）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /var/www<span class="token function">wget</span> https://files.phpmyadmin.net/phpMyAdmin/4.8.2/phpMyAdmin-4.8.2-all-languages.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>解压</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> vzxf 包名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>修改解压后得到的文件夹名为phpmyadmin （为之后访问方便）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> 解压得到的文件夹/ phpmyadmin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>进入文件夹 </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> phpmyadmin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="2-建立主配置文件"><a href="#2-建立主配置文件" class="headerlink" title="2.建立主配置文件"></a>2.建立主配置文件</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> config.sample.inc.php config.inc.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3.修改配置文件"></a>3.修改配置文件</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> config.inc.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$cfg</span><span class="token punctuation">[</span>‘blowfish_secret’<span class="token punctuation">]</span> <span class="token operator">=</span> ”<span class="token punctuation">;</span> <span class="token comment">/* 自己在引号里面随便填 */</span> <span class="token variable">$cfg</span><span class="token punctuation">[</span>‘Servers’<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">[</span>‘host’<span class="token punctuation">]</span> <span class="token operator">=</span>‘<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span>’  <span class="token comment">/*改成127.0.0.1*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h5 id="4-启动httpd-mysqld服务"><a href="#4-启动httpd-mysqld服务" class="headerlink" title="4.启动httpd+mysqld服务"></a>4.启动httpd+mysqld服务</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">service</span> mysqld start<span class="token function">service</span> httpd restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>浏览器输入主机地址&#x2F;phpmyadmin 即可登录</p><h2 id="安装python3-6及pip3"><a href="#安装python3-6及pip3" class="headerlink" title="安装python3.6及pip3"></a>安装python3.6及pip3</h2><h6 id="1-安装python3-6"><a href="#1-安装python3-6" class="headerlink" title="1.安装python3.6"></a>1.安装python3.6</h6><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> epel-release   <span class="token comment">#安装epel源</span>yum <span class="token function">install</span> python36 python36-devel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h5 id="2-软链接"><a href="#2-软链接" class="headerlink" title="2.软链接"></a>2.软链接</h5><p>一般来说，在&#x2F;usr&#x2F;bin 会有python3.6 这时我们可以设一个软链接给他</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ln</span> <span class="token parameter variable">-s</span> /usr/bin/python3.6 python3 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这样我们一运行python3即可打开python3.6</p><h5 id="3-安装3-6对应的pip3"><a href="#3-安装3-6对应的pip3" class="headerlink" title="3.安装3.6对应的pip3"></a>3.安装3.6对应的pip3</h5><p>（为防止后期pip安装时混乱，此处我们只安装pip3）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> python36-setuptoolseasy_install-3.6 pip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h5 id="4-安装检测"><a href="#4-安装检测" class="headerlink" title="4.安装检测"></a>4.安装检测</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>出现各种参数说明安装成功<br>如果你还想安装pip可参考<a href="https://blog.csdn.net/zuolovefu/article/details/78142612">https://blog.csdn.net/zuolovefu/article/details/78142612</a></p><h5 id="5-模块安装"><a href="#5-模块安装" class="headerlink" title="5.模块安装"></a>5.模块安装</h5><p>关于需要用到的各种python3模块（笔者的Django 项目会用到这些，大家根据自己的需求自行安装）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip3 <span class="token function">install</span> djangopip3 <span class="token function">install</span> requestspip3 <span class="token function">install</span> bs4pip3 <span class="token function">install</span> lxmlyum <span class="token function">install</span> mysql-develpip3 <span class="token function">install</span> mysqlclient<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="安装并配置mod-wsgi"><a href="#安装并配置mod-wsgi" class="headerlink" title="安装并配置mod_wsgi"></a>安装并配置mod_wsgi</h2><h6 id="1-下载新版的wsgi"><a href="#1-下载新版的wsgi" class="headerlink" title="1.下载新版的wsgi"></a>1.下载新版的wsgi</h6><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> 进入根目录<span class="token function">wget</span> https://github.com/GrahamDumpleton/mod_wsgi/archive/develop.zip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>解压包并进入解压得到的文件夹</p><h5 id="2-编译安装"><a href="#2-编译安装" class="headerlink" title="2.编译安装"></a>2.编译安装</h5><p>这一步configure很重要（它会列出一堆，看apxs gcc python等是否关联正确 不出现no的都是能关联到的。会有一部分是no不管他）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure --with-python<span class="token operator">=</span>/usr/bin/python3.6 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="3-在apache中加载模块"><a href="#3-在apache中加载模块" class="headerlink" title="3.在apache中加载模块"></a>3.在apache中加载模块</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/httpd/conf/httpd.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>在文件中加入：</p><figure><div class="code-wrapper"><pre class="line-numbers language-apacheconf" data-language="apacheconf"><code class="language-apacheconf"><span class="token directive-inline property">LoadModule</span> wsgi_module /usr/lib64/httpd/modules/mod_wsgi.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>保存后重启Apache：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apachectl restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="关于在apache上配合mod-wsgi部署Django"><a href="#关于在apache上配合mod-wsgi部署Django" class="headerlink" title="关于在apache上配合mod_wsgi部署Django"></a>关于在apache上配合mod_wsgi部署Django</h2><h5 id="1-runserver-or-check"><a href="#1-runserver-or-check" class="headerlink" title="1.runserver or check"></a>1.runserver or check</h5><p>建议先在主机上通过runserver 或者check测试下django框架是否已经正确搭建、关联好了数据库并且本机不缺少依赖。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#开启8080端口 然后浏览器里 http://服务器公网ip:8080  把功能试一试</span>python3 manage.py runserver <span class="token number">0.0</span>.0.0:8080<span class="token comment">#或者check(但针对非语法错误不一定好使)</span>python3 manage.py check<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h5 id="2-赋权限"><a href="#2-赋权限" class="headerlink" title="2.赋权限"></a>2.赋权限</h5><p>其次， 在工程文件夹外 将工程文件夹以及其子目录下文件赋予755权限：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token parameter variable">-R</span> <span class="token number">755</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="3-修改Django-x2F-wsgi-py"><a href="#3-修改Django-x2F-wsgi-py" class="headerlink" title="3.修改Django&#x2F;wsgi.py"></a>3.修改Django&#x2F;wsgi.py</h5><p>修改<code>wsgi.py </code>文件内容如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">import osfrom django.core.wsgi import get_wsgi_applicationfrom os.path import join, dirname, abspathPROJECT_DIR &#x3D; dirname(dirname(abspath(__file__)))import syssys.path.insert(0, PROJECT_DIR)os.environ.setdefault(“DJANGO_SETTINGS_MODULE”, “first.settings”)application &#x3D; get_wsgi_application()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h5 id="4-修改apache配置文件"><a href="#4-修改apache配置文件" class="headerlink" title="4.修改apache配置文件"></a>4.修改apache配置文件</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/httpd/conf/httpd.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>在文件末尾加入如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-apacheconf" data-language="apacheconf"><code class="language-apacheconf">WSGIScriptAlias / /path/to/mysite.com/mysite/wsgi.pyWSGIPythonHome /path/to/venvWSGIPythonPath /path/to/mysite.com<span class="token directive-block tag"><span class="token directive-block tag"><span class="token punctuation">&lt;</span>Directory</span><span class="token directive-block-parameter attr-value"> /path/to/mysite.com/mysite</span><span class="token punctuation">></span></span><span class="token directive-block tag"><span class="token directive-block tag"><span class="token punctuation">&lt;</span>Files</span><span class="token directive-block-parameter attr-value"> wsgi.py</span><span class="token punctuation">></span></span><span class="token directive-inline property">Require</span> all granted<span class="token directive-block tag"><span class="token directive-block tag"><span class="token punctuation">&lt;/</span>Files</span><span class="token punctuation">></span></span><span class="token directive-block tag"><span class="token directive-block tag"><span class="token punctuation">&lt;/</span>Directory</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>然后保存退出，重启apache</p><p>我们来解释一下:<br>（1）第一行包含两部分 第一个地址表示apache从URL的哪开始是运行Django 第二地址是你Django 项目中wsgi.py的位置<br>（2）第二行是你所选择执行你Django程序的python解释器安装目录（如果安装wsgi时已正确指定则可省略）<br>（3）第三行是django项目的位置<br>（4）&lt;Directory 后面上Django 项目的基础配置文件所在目录（一般是和项目目录同名的子目录）<br>余下部分照常</p><p>假如我现在的主机地址为119.23.33.217 开放端口是80<br>我的Django 项目名是first     项目所在目录是&#x2F;etc&#x2F;Django&#x2F;First&#x2F;first<br>并且安装wsgi时我已经指定了python3.6（因为我的Django用的是python3）<br>我希望在浏览器中输入 119.23.33.217&#x2F;wepr&#x2F;xxxxx 的时候可以触发我的Django框架<br>那么我的配置文件应该这样写</p><figure><div class="code-wrapper"><pre class="line-numbers language-apacheconf" data-language="apacheconf"><code class="language-apacheconf">WSGIScriptAlias /wepr /etc/Django/First/first/first/wsgi.pyWSGIPythonPath /etc/Django/First/first<span class="token directive-block tag"><span class="token directive-block tag"><span class="token punctuation">&lt;</span>Directory</span><span class="token directive-block-parameter attr-value"> /etc/Django/First/first/first/</span><span class="token punctuation">></span></span><span class="token directive-block tag"><span class="token directive-block tag"><span class="token punctuation">&lt;</span>Files</span><span class="token directive-block-parameter attr-value"> wsgi.py</span><span class="token punctuation">></span></span><span class="token directive-inline property">Require</span> all granted<span class="token directive-block tag"><span class="token directive-block tag"><span class="token punctuation">&lt;/</span>Files</span><span class="token punctuation">></span></span><span class="token directive-block tag"><span class="token directive-block tag"><span class="token punctuation">&lt;/</span>Directory</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××<br>关于WSGIScriptAlias中设置子目录的问题：<br>如果采用 WSGIScriptAlias &#x2F; &#x2F;etc&#x2F;Django&#x2F;First&#x2F;first&#x2F;first&#x2F;wsgi.py<br>当你访问119.23.33.217时，就只能触发django，而之前配置的phpmyadmin都不能访问<br>为了合理分配服务器的区块，提高利用效率，建议专门给Django一个虚拟子目录作为“分区”<br>××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××</p><p>以上属于笔者经验  如果大家在安装中出现其它问题或者发现本文疏漏 欢迎大家在下面评论</p><p>本文内容是笔者入门服务器部署时的流水账记录，二次整理到CSDN时，没有再对原内容进行修改，难免会有一些偏差认识，搬到这里来其实怀旧记录的成分更多一点。2020，岁月可期！</p><p>RHEL8都问世好久了，LNMP部署或用容器、或用更友好的管理面板(如宝塔Linux) 笔者之后如果再遇到类似的环境重部署时，会整理一篇新的内容(文笔肯定不会这么滞涩啦 ~hh)~~</p>]]></content>
    
    
    <categories>
      
      <category>经验整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CentOS7</tag>
      
      <tag>Django</tag>
      
      <tag>Apache</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
